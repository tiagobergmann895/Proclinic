
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemBatch
 * 
 */
export type ItemBatch = $Result.DefaultSelection<Prisma.$ItemBatchPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model ProcedureType
 * 
 */
export type ProcedureType = $Result.DefaultSelection<Prisma.$ProcedureTypePayload>
/**
 * Model Procedure
 * 
 */
export type Procedure = $Result.DefaultSelection<Prisma.$ProcedurePayload>
/**
 * Model CostSheet
 * 
 */
export type CostSheet = $Result.DefaultSelection<Prisma.$CostSheetPayload>
/**
 * Model PriceRule
 * 
 */
export type PriceRule = $Result.DefaultSelection<Prisma.$PriceRulePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ClinicalNote
 * 
 */
export type ClinicalNote = $Result.DefaultSelection<Prisma.$ClinicalNotePayload>
/**
 * Model Observation
 * 
 */
export type Observation = $Result.DefaultSelection<Prisma.$ObservationPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model DiagnosticReport
 * 
 */
export type DiagnosticReport = $Result.DefaultSelection<Prisma.$DiagnosticReportPayload>
/**
 * Model AllergyIntolerance
 * 
 */
export type AllergyIntolerance = $Result.DefaultSelection<Prisma.$AllergyIntolerancePayload>
/**
 * Model DocumentReference
 * 
 */
export type DocumentReference = $Result.DefaultSelection<Prisma.$DocumentReferencePayload>
/**
 * Model Condition
 * 
 */
export type Condition = $Result.DefaultSelection<Prisma.$ConditionPayload>
/**
 * Model Immunization
 * 
 */
export type Immunization = $Result.DefaultSelection<Prisma.$ImmunizationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  recepcao: 'recepcao',
  profissional: 'profissional',
  financeiro: 'financeiro',
  gestor: 'gestor'
};

export type Role = (typeof Role)[keyof typeof Role]


export const MovementType: {
  ENTRY: 'ENTRY',
  EXIT: 'EXIT',
  ADJUST: 'ADJUST'
};

export type MovementType = (typeof MovementType)[keyof typeof MovementType]


export const ProcedureStatus: {
  SCHEDULED: 'SCHEDULED',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED'
};

export type ProcedureStatus = (typeof ProcedureStatus)[keyof typeof ProcedureStatus]


export const PriceScope: {
  PROCEDURE_TYPE: 'PROCEDURE_TYPE',
  GLOBAL: 'GLOBAL'
};

export type PriceScope = (typeof PriceScope)[keyof typeof PriceScope]


export const PaymentMethod: {
  PIX: 'PIX',
  CARD: 'CARD',
  BOLETO: 'BOLETO',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type MovementType = $Enums.MovementType

export const MovementType: typeof $Enums.MovementType

export type ProcedureStatus = $Enums.ProcedureStatus

export const ProcedureStatus: typeof $Enums.ProcedureStatus

export type PriceScope = $Enums.PriceScope

export const PriceScope: typeof $Enums.PriceScope

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemBatch`: Exposes CRUD operations for the **ItemBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemBatches
    * const itemBatches = await prisma.itemBatch.findMany()
    * ```
    */
  get itemBatch(): Prisma.ItemBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procedureType`: Exposes CRUD operations for the **ProcedureType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcedureTypes
    * const procedureTypes = await prisma.procedureType.findMany()
    * ```
    */
  get procedureType(): Prisma.ProcedureTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procedure`: Exposes CRUD operations for the **Procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedures
    * const procedures = await prisma.procedure.findMany()
    * ```
    */
  get procedure(): Prisma.ProcedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costSheet`: Exposes CRUD operations for the **CostSheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostSheets
    * const costSheets = await prisma.costSheet.findMany()
    * ```
    */
  get costSheet(): Prisma.CostSheetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceRule`: Exposes CRUD operations for the **PriceRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceRules
    * const priceRules = await prisma.priceRule.findMany()
    * ```
    */
  get priceRule(): Prisma.PriceRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicalNote`: Exposes CRUD operations for the **ClinicalNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalNotes
    * const clinicalNotes = await prisma.clinicalNote.findMany()
    * ```
    */
  get clinicalNote(): Prisma.ClinicalNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.observation`: Exposes CRUD operations for the **Observation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Observations
    * const observations = await prisma.observation.findMany()
    * ```
    */
  get observation(): Prisma.ObservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnosticReport`: Exposes CRUD operations for the **DiagnosticReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiagnosticReports
    * const diagnosticReports = await prisma.diagnosticReport.findMany()
    * ```
    */
  get diagnosticReport(): Prisma.DiagnosticReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allergyIntolerance`: Exposes CRUD operations for the **AllergyIntolerance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AllergyIntolerances
    * const allergyIntolerances = await prisma.allergyIntolerance.findMany()
    * ```
    */
  get allergyIntolerance(): Prisma.AllergyIntoleranceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentReference`: Exposes CRUD operations for the **DocumentReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentReferences
    * const documentReferences = await prisma.documentReference.findMany()
    * ```
    */
  get documentReference(): Prisma.DocumentReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.condition`: Exposes CRUD operations for the **Condition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditions
    * const conditions = await prisma.condition.findMany()
    * ```
    */
  get condition(): Prisma.ConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.immunization`: Exposes CRUD operations for the **Immunization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Immunizations
    * const immunizations = await prisma.immunization.findMany()
    * ```
    */
  get immunization(): Prisma.ImmunizationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Patient: 'Patient',
    Supplier: 'Supplier',
    Item: 'Item',
    ItemBatch: 'ItemBatch',
    InventoryMovement: 'InventoryMovement',
    ProcedureType: 'ProcedureType',
    Procedure: 'Procedure',
    CostSheet: 'CostSheet',
    PriceRule: 'PriceRule',
    Payment: 'Payment',
    AuditLog: 'AuditLog',
    ClinicalNote: 'ClinicalNote',
    Observation: 'Observation',
    Prescription: 'Prescription',
    DiagnosticReport: 'DiagnosticReport',
    AllergyIntolerance: 'AllergyIntolerance',
    DocumentReference: 'DocumentReference',
    Condition: 'Condition',
    Immunization: 'Immunization'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "patient" | "supplier" | "item" | "itemBatch" | "inventoryMovement" | "procedureType" | "procedure" | "costSheet" | "priceRule" | "payment" | "auditLog" | "clinicalNote" | "observation" | "prescription" | "diagnosticReport" | "allergyIntolerance" | "documentReference" | "condition" | "immunization"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemBatch: {
        payload: Prisma.$ItemBatchPayload<ExtArgs>
        fields: Prisma.ItemBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          findFirst: {
            args: Prisma.ItemBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          findMany: {
            args: Prisma.ItemBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>[]
          }
          create: {
            args: Prisma.ItemBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          createMany: {
            args: Prisma.ItemBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>[]
          }
          delete: {
            args: Prisma.ItemBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          update: {
            args: Prisma.ItemBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          deleteMany: {
            args: Prisma.ItemBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemBatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>[]
          }
          upsert: {
            args: Prisma.ItemBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemBatchPayload>
          }
          aggregate: {
            args: Prisma.ItemBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemBatch>
          }
          groupBy: {
            args: Prisma.ItemBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemBatchCountArgs<ExtArgs>
            result: $Utils.Optional<ItemBatchCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      ProcedureType: {
        payload: Prisma.$ProcedureTypePayload<ExtArgs>
        fields: Prisma.ProcedureTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          findFirst: {
            args: Prisma.ProcedureTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          findMany: {
            args: Prisma.ProcedureTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>[]
          }
          create: {
            args: Prisma.ProcedureTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          createMany: {
            args: Prisma.ProcedureTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>[]
          }
          delete: {
            args: Prisma.ProcedureTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          update: {
            args: Prisma.ProcedureTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcedureTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>[]
          }
          upsert: {
            args: Prisma.ProcedureTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureTypePayload>
          }
          aggregate: {
            args: Prisma.ProcedureTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedureType>
          }
          groupBy: {
            args: Prisma.ProcedureTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureTypeCountAggregateOutputType> | number
          }
        }
      }
      Procedure: {
        payload: Prisma.$ProcedurePayload<ExtArgs>
        fields: Prisma.ProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findFirst: {
            args: Prisma.ProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findMany: {
            args: Prisma.ProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          create: {
            args: Prisma.ProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          createMany: {
            args: Prisma.ProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          delete: {
            args: Prisma.ProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          update: {
            args: Prisma.ProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          upsert: {
            args: Prisma.ProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          aggregate: {
            args: Prisma.ProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedure>
          }
          groupBy: {
            args: Prisma.ProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureCountAggregateOutputType> | number
          }
        }
      }
      CostSheet: {
        payload: Prisma.$CostSheetPayload<ExtArgs>
        fields: Prisma.CostSheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostSheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostSheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          findFirst: {
            args: Prisma.CostSheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostSheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          findMany: {
            args: Prisma.CostSheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>[]
          }
          create: {
            args: Prisma.CostSheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          createMany: {
            args: Prisma.CostSheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostSheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>[]
          }
          delete: {
            args: Prisma.CostSheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          update: {
            args: Prisma.CostSheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          deleteMany: {
            args: Prisma.CostSheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostSheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostSheetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>[]
          }
          upsert: {
            args: Prisma.CostSheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostSheetPayload>
          }
          aggregate: {
            args: Prisma.CostSheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostSheet>
          }
          groupBy: {
            args: Prisma.CostSheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostSheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostSheetCountArgs<ExtArgs>
            result: $Utils.Optional<CostSheetCountAggregateOutputType> | number
          }
        }
      }
      PriceRule: {
        payload: Prisma.$PriceRulePayload<ExtArgs>
        fields: Prisma.PriceRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          findFirst: {
            args: Prisma.PriceRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          findMany: {
            args: Prisma.PriceRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>[]
          }
          create: {
            args: Prisma.PriceRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          createMany: {
            args: Prisma.PriceRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>[]
          }
          delete: {
            args: Prisma.PriceRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          update: {
            args: Prisma.PriceRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          deleteMany: {
            args: Prisma.PriceRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>[]
          }
          upsert: {
            args: Prisma.PriceRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceRulePayload>
          }
          aggregate: {
            args: Prisma.PriceRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceRule>
          }
          groupBy: {
            args: Prisma.PriceRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceRuleCountArgs<ExtArgs>
            result: $Utils.Optional<PriceRuleCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ClinicalNote: {
        payload: Prisma.$ClinicalNotePayload<ExtArgs>
        fields: Prisma.ClinicalNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findFirst: {
            args: Prisma.ClinicalNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findMany: {
            args: Prisma.ClinicalNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          create: {
            args: Prisma.ClinicalNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          createMany: {
            args: Prisma.ClinicalNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          delete: {
            args: Prisma.ClinicalNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          update: {
            args: Prisma.ClinicalNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          deleteMany: {
            args: Prisma.ClinicalNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          upsert: {
            args: Prisma.ClinicalNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          aggregate: {
            args: Prisma.ClinicalNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalNote>
          }
          groupBy: {
            args: Prisma.ClinicalNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteCountAggregateOutputType> | number
          }
        }
      }
      Observation: {
        payload: Prisma.$ObservationPayload<ExtArgs>
        fields: Prisma.ObservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findFirst: {
            args: Prisma.ObservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findMany: {
            args: Prisma.ObservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          create: {
            args: Prisma.ObservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          createMany: {
            args: Prisma.ObservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          delete: {
            args: Prisma.ObservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          update: {
            args: Prisma.ObservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          deleteMany: {
            args: Prisma.ObservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          upsert: {
            args: Prisma.ObservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          aggregate: {
            args: Prisma.ObservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservation>
          }
          groupBy: {
            args: Prisma.ObservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      DiagnosticReport: {
        payload: Prisma.$DiagnosticReportPayload<ExtArgs>
        fields: Prisma.DiagnosticReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosticReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosticReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          findFirst: {
            args: Prisma.DiagnosticReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosticReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          findMany: {
            args: Prisma.DiagnosticReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>[]
          }
          create: {
            args: Prisma.DiagnosticReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          createMany: {
            args: Prisma.DiagnosticReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosticReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>[]
          }
          delete: {
            args: Prisma.DiagnosticReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          update: {
            args: Prisma.DiagnosticReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosticReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosticReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiagnosticReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>[]
          }
          upsert: {
            args: Prisma.DiagnosticReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosticReportPayload>
          }
          aggregate: {
            args: Prisma.DiagnosticReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosticReport>
          }
          groupBy: {
            args: Prisma.DiagnosticReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosticReportCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticReportCountAggregateOutputType> | number
          }
        }
      }
      AllergyIntolerance: {
        payload: Prisma.$AllergyIntolerancePayload<ExtArgs>
        fields: Prisma.AllergyIntoleranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergyIntoleranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergyIntoleranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          findFirst: {
            args: Prisma.AllergyIntoleranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergyIntoleranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          findMany: {
            args: Prisma.AllergyIntoleranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>[]
          }
          create: {
            args: Prisma.AllergyIntoleranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          createMany: {
            args: Prisma.AllergyIntoleranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllergyIntoleranceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>[]
          }
          delete: {
            args: Prisma.AllergyIntoleranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          update: {
            args: Prisma.AllergyIntoleranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          deleteMany: {
            args: Prisma.AllergyIntoleranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllergyIntoleranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllergyIntoleranceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>[]
          }
          upsert: {
            args: Prisma.AllergyIntoleranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergyIntolerancePayload>
          }
          aggregate: {
            args: Prisma.AllergyIntoleranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllergyIntolerance>
          }
          groupBy: {
            args: Prisma.AllergyIntoleranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllergyIntoleranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergyIntoleranceCountArgs<ExtArgs>
            result: $Utils.Optional<AllergyIntoleranceCountAggregateOutputType> | number
          }
        }
      }
      DocumentReference: {
        payload: Prisma.$DocumentReferencePayload<ExtArgs>
        fields: Prisma.DocumentReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          findFirst: {
            args: Prisma.DocumentReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          findMany: {
            args: Prisma.DocumentReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>[]
          }
          create: {
            args: Prisma.DocumentReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          createMany: {
            args: Prisma.DocumentReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentReferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>[]
          }
          delete: {
            args: Prisma.DocumentReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          update: {
            args: Prisma.DocumentReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          deleteMany: {
            args: Prisma.DocumentReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentReferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>[]
          }
          upsert: {
            args: Prisma.DocumentReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReferencePayload>
          }
          aggregate: {
            args: Prisma.DocumentReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentReference>
          }
          groupBy: {
            args: Prisma.DocumentReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentReferenceCountAggregateOutputType> | number
          }
        }
      }
      Condition: {
        payload: Prisma.$ConditionPayload<ExtArgs>
        fields: Prisma.ConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findFirst: {
            args: Prisma.ConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findMany: {
            args: Prisma.ConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          create: {
            args: Prisma.ConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          createMany: {
            args: Prisma.ConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          delete: {
            args: Prisma.ConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          update: {
            args: Prisma.ConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          deleteMany: {
            args: Prisma.ConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          upsert: {
            args: Prisma.ConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          aggregate: {
            args: Prisma.ConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCondition>
          }
          groupBy: {
            args: Prisma.ConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionCountArgs<ExtArgs>
            result: $Utils.Optional<ConditionCountAggregateOutputType> | number
          }
        }
      }
      Immunization: {
        payload: Prisma.$ImmunizationPayload<ExtArgs>
        fields: Prisma.ImmunizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImmunizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImmunizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          findFirst: {
            args: Prisma.ImmunizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImmunizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          findMany: {
            args: Prisma.ImmunizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>[]
          }
          create: {
            args: Prisma.ImmunizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          createMany: {
            args: Prisma.ImmunizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImmunizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>[]
          }
          delete: {
            args: Prisma.ImmunizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          update: {
            args: Prisma.ImmunizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          deleteMany: {
            args: Prisma.ImmunizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImmunizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImmunizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>[]
          }
          upsert: {
            args: Prisma.ImmunizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationPayload>
          }
          aggregate: {
            args: Prisma.ImmunizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImmunization>
          }
          groupBy: {
            args: Prisma.ImmunizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImmunizationCountArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    patient?: PatientOmit
    supplier?: SupplierOmit
    item?: ItemOmit
    itemBatch?: ItemBatchOmit
    inventoryMovement?: InventoryMovementOmit
    procedureType?: ProcedureTypeOmit
    procedure?: ProcedureOmit
    costSheet?: CostSheetOmit
    priceRule?: PriceRuleOmit
    payment?: PaymentOmit
    auditLog?: AuditLogOmit
    clinicalNote?: ClinicalNoteOmit
    observation?: ObservationOmit
    prescription?: PrescriptionOmit
    diagnosticReport?: DiagnosticReportOmit
    allergyIntolerance?: AllergyIntoleranceOmit
    documentReference?: DocumentReferenceOmit
    condition?: ConditionOmit
    immunization?: ImmunizationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    procedures: number
    auditLogs: number
    inventoryMovements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | UserCountOutputTypeCountProceduresArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    inventoryMovements?: boolean | UserCountOutputTypeCountInventoryMovementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    procedures: number
    conditions: number
    allergies: number
    medications: number
    immunizations: number
    clinicalNotes: number
    observations: number
    diagnosticReports: number
    documentReferences: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | PatientCountOutputTypeCountProceduresArgs
    conditions?: boolean | PatientCountOutputTypeCountConditionsArgs
    allergies?: boolean | PatientCountOutputTypeCountAllergiesArgs
    medications?: boolean | PatientCountOutputTypeCountMedicationsArgs
    immunizations?: boolean | PatientCountOutputTypeCountImmunizationsArgs
    clinicalNotes?: boolean | PatientCountOutputTypeCountClinicalNotesArgs
    observations?: boolean | PatientCountOutputTypeCountObservationsArgs
    diagnosticReports?: boolean | PatientCountOutputTypeCountDiagnosticReportsArgs
    documentReferences?: boolean | PatientCountOutputTypeCountDocumentReferencesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyIntoleranceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountImmunizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountClinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountObservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDiagnosticReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosticReportWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDocumentReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReferenceWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    batches: number
    movements: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | ItemCountOutputTypeCountBatchesArgs
    movements?: boolean | ItemCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemBatchWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type ItemBatchCountOutputType
   */

  export type ItemBatchCountOutputType = {
    movements: number
  }

  export type ItemBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | ItemBatchCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * ItemBatchCountOutputType without action
   */
  export type ItemBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatchCountOutputType
     */
    select?: ItemBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemBatchCountOutputType without action
   */
  export type ItemBatchCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type ProcedureTypeCountOutputType
   */

  export type ProcedureTypeCountOutputType = {
    procedures: number
  }

  export type ProcedureTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | ProcedureTypeCountOutputTypeCountProceduresArgs
  }

  // Custom InputTypes
  /**
   * ProcedureTypeCountOutputType without action
   */
  export type ProcedureTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureTypeCountOutputType
     */
    select?: ProcedureTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedureTypeCountOutputType without action
   */
  export type ProcedureTypeCountOutputTypeCountProceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
  }


  /**
   * Count Type ProcedureCountOutputType
   */

  export type ProcedureCountOutputType = {
    payments: number
  }

  export type ProcedureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | ProcedureCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureCountOutputType
     */
    select?: ProcedureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    role: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procedures?: boolean | User$proceduresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "role" | "passwordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | User$proceduresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      role: $Enums.Role
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedures<T extends User$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, User$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends User$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.procedures
   */
  export type User$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.inventoryMovements
   */
  export type User$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    name: string | null
    birthDate: Date | null
    document: string | null
    phone: string | null
    email: string | null
    address: string | null
    consentGivenAt: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    birthDate: Date | null
    document: string | null
    phone: string | null
    email: string | null
    address: string | null
    consentGivenAt: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    name: number
    birthDate: number
    document: number
    phone: number
    email: number
    address: number
    consentGivenAt: number
    notes: number
    createdAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    name?: true
    birthDate?: true
    document?: true
    phone?: true
    email?: true
    address?: true
    consentGivenAt?: true
    notes?: true
    createdAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    name?: true
    birthDate?: true
    document?: true
    phone?: true
    email?: true
    address?: true
    consentGivenAt?: true
    notes?: true
    createdAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    name?: true
    birthDate?: true
    document?: true
    phone?: true
    email?: true
    address?: true
    consentGivenAt?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    name: string
    birthDate: Date | null
    document: string | null
    phone: string | null
    email: string | null
    address: string | null
    consentGivenAt: Date | null
    notes: string | null
    createdAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    birthDate?: boolean
    document?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    consentGivenAt?: boolean
    notes?: boolean
    createdAt?: boolean
    procedures?: boolean | Patient$proceduresArgs<ExtArgs>
    conditions?: boolean | Patient$conditionsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    immunizations?: boolean | Patient$immunizationsArgs<ExtArgs>
    clinicalNotes?: boolean | Patient$clinicalNotesArgs<ExtArgs>
    observations?: boolean | Patient$observationsArgs<ExtArgs>
    diagnosticReports?: boolean | Patient$diagnosticReportsArgs<ExtArgs>
    documentReferences?: boolean | Patient$documentReferencesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    birthDate?: boolean
    document?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    consentGivenAt?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    birthDate?: boolean
    document?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    consentGivenAt?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    name?: boolean
    birthDate?: boolean
    document?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    consentGivenAt?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "birthDate" | "document" | "phone" | "email" | "address" | "consentGivenAt" | "notes" | "createdAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | Patient$proceduresArgs<ExtArgs>
    conditions?: boolean | Patient$conditionsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    medications?: boolean | Patient$medicationsArgs<ExtArgs>
    immunizations?: boolean | Patient$immunizationsArgs<ExtArgs>
    clinicalNotes?: boolean | Patient$clinicalNotesArgs<ExtArgs>
    observations?: boolean | Patient$observationsArgs<ExtArgs>
    diagnosticReports?: boolean | Patient$diagnosticReportsArgs<ExtArgs>
    documentReferences?: boolean | Patient$documentReferencesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
      conditions: Prisma.$ConditionPayload<ExtArgs>[]
      allergies: Prisma.$AllergyIntolerancePayload<ExtArgs>[]
      medications: Prisma.$PrescriptionPayload<ExtArgs>[]
      immunizations: Prisma.$ImmunizationPayload<ExtArgs>[]
      clinicalNotes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      observations: Prisma.$ObservationPayload<ExtArgs>[]
      diagnosticReports: Prisma.$DiagnosticReportPayload<ExtArgs>[]
      documentReferences: Prisma.$DocumentReferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      birthDate: Date | null
      document: string | null
      phone: string | null
      email: string | null
      address: string | null
      consentGivenAt: Date | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedures<T extends Patient$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, Patient$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conditions<T extends Patient$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allergies<T extends Patient$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Patient$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    immunizations<T extends Patient$immunizationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$immunizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicalNotes<T extends Patient$clinicalNotesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$clinicalNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    observations<T extends Patient$observationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$observationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnosticReports<T extends Patient$diagnosticReportsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$diagnosticReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentReferences<T extends Patient$documentReferencesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$documentReferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly document: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly consentGivenAt: FieldRef<"Patient", 'DateTime'>
    readonly notes: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.procedures
   */
  export type Patient$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Patient.conditions
   */
  export type Patient$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    where?: ConditionWhereInput
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    cursor?: ConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Patient.allergies
   */
  export type Patient$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    where?: AllergyIntoleranceWhereInput
    orderBy?: AllergyIntoleranceOrderByWithRelationInput | AllergyIntoleranceOrderByWithRelationInput[]
    cursor?: AllergyIntoleranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergyIntoleranceScalarFieldEnum | AllergyIntoleranceScalarFieldEnum[]
  }

  /**
   * Patient.medications
   */
  export type Patient$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.immunizations
   */
  export type Patient$immunizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    where?: ImmunizationWhereInput
    orderBy?: ImmunizationOrderByWithRelationInput | ImmunizationOrderByWithRelationInput[]
    cursor?: ImmunizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImmunizationScalarFieldEnum | ImmunizationScalarFieldEnum[]
  }

  /**
   * Patient.clinicalNotes
   */
  export type Patient$clinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * Patient.observations
   */
  export type Patient$observationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    cursor?: ObservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Patient.diagnosticReports
   */
  export type Patient$diagnosticReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    where?: DiagnosticReportWhereInput
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    cursor?: DiagnosticReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }

  /**
   * Patient.documentReferences
   */
  export type Patient$documentReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    where?: DocumentReferenceWhereInput
    orderBy?: DocumentReferenceOrderByWithRelationInput | DocumentReferenceOrderByWithRelationInput[]
    cursor?: DocumentReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentReferenceScalarFieldEnum | DocumentReferenceScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    contact: string | null
    email: string | null
    phone: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    contact: string | null
    email: string | null
    phone: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    cnpj: number
    contact: number
    email: number
    phone: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    contact?: true
    email?: true
    phone?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    contact?: true
    email?: true
    phone?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    contact?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    cnpj: string | null
    contact: string | null
    email: string | null
    phone: string | null
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    cnpj?: boolean
    contact?: boolean
    email?: boolean
    phone?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cnpj" | "contact" | "email" | "phone", ExtArgs["result"]["supplier"]>

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cnpj: string | null
      contact: string | null
      email: string | null
      phone: string | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly cnpj: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    minStock: number | null
  }

  export type ItemSumAggregateOutputType = {
    minStock: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unit: string | null
    sku: string | null
    minStock: number | null
    isControlled: boolean | null
    createdAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unit: string | null
    sku: string | null
    minStock: number | null
    isControlled: boolean | null
    createdAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    category: number
    unit: number
    sku: number
    minStock: number
    isControlled: number
    createdAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    minStock?: true
  }

  export type ItemSumAggregateInputType = {
    minStock?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    sku?: true
    minStock?: true
    isControlled?: true
    createdAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    sku?: true
    minStock?: true
    isControlled?: true
    createdAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    sku?: true
    minStock?: true
    isControlled?: true
    createdAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    category: string | null
    unit: string
    sku: string | null
    minStock: number
    isControlled: boolean
    createdAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    sku?: boolean
    minStock?: boolean
    isControlled?: boolean
    createdAt?: boolean
    batches?: boolean | Item$batchesArgs<ExtArgs>
    movements?: boolean | Item$movementsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    sku?: boolean
    minStock?: boolean
    isControlled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    sku?: boolean
    minStock?: boolean
    isControlled?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    sku?: boolean
    minStock?: boolean
    isControlled?: boolean
    createdAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "unit" | "sku" | "minStock" | "isControlled" | "createdAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Item$batchesArgs<ExtArgs>
    movements?: boolean | Item$movementsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      batches: Prisma.$ItemBatchPayload<ExtArgs>[]
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      unit: string
      sku: string | null
      minStock: number
      isControlled: boolean
      createdAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Item$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Item$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movements<T extends Item$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Item$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly category: FieldRef<"Item", 'String'>
    readonly unit: FieldRef<"Item", 'String'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly minStock: FieldRef<"Item", 'Float'>
    readonly isControlled: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.batches
   */
  export type Item$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    where?: ItemBatchWhereInput
    orderBy?: ItemBatchOrderByWithRelationInput | ItemBatchOrderByWithRelationInput[]
    cursor?: ItemBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemBatchScalarFieldEnum | ItemBatchScalarFieldEnum[]
  }

  /**
   * Item.movements
   */
  export type Item$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model ItemBatch
   */

  export type AggregateItemBatch = {
    _count: ItemBatchCountAggregateOutputType | null
    _avg: ItemBatchAvgAggregateOutputType | null
    _sum: ItemBatchSumAggregateOutputType | null
    _min: ItemBatchMinAggregateOutputType | null
    _max: ItemBatchMaxAggregateOutputType | null
  }

  export type ItemBatchAvgAggregateOutputType = {
    unitCost: Decimal | null
    quantityAvailable: Decimal | null
  }

  export type ItemBatchSumAggregateOutputType = {
    unitCost: Decimal | null
    quantityAvailable: Decimal | null
  }

  export type ItemBatchMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    batchCode: string | null
    expirationDate: Date | null
    unitCost: Decimal | null
    quantityAvailable: Decimal | null
    createdAt: Date | null
  }

  export type ItemBatchMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    batchCode: string | null
    expirationDate: Date | null
    unitCost: Decimal | null
    quantityAvailable: Decimal | null
    createdAt: Date | null
  }

  export type ItemBatchCountAggregateOutputType = {
    id: number
    itemId: number
    batchCode: number
    expirationDate: number
    unitCost: number
    quantityAvailable: number
    createdAt: number
    _all: number
  }


  export type ItemBatchAvgAggregateInputType = {
    unitCost?: true
    quantityAvailable?: true
  }

  export type ItemBatchSumAggregateInputType = {
    unitCost?: true
    quantityAvailable?: true
  }

  export type ItemBatchMinAggregateInputType = {
    id?: true
    itemId?: true
    batchCode?: true
    expirationDate?: true
    unitCost?: true
    quantityAvailable?: true
    createdAt?: true
  }

  export type ItemBatchMaxAggregateInputType = {
    id?: true
    itemId?: true
    batchCode?: true
    expirationDate?: true
    unitCost?: true
    quantityAvailable?: true
    createdAt?: true
  }

  export type ItemBatchCountAggregateInputType = {
    id?: true
    itemId?: true
    batchCode?: true
    expirationDate?: true
    unitCost?: true
    quantityAvailable?: true
    createdAt?: true
    _all?: true
  }

  export type ItemBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemBatch to aggregate.
     */
    where?: ItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBatches to fetch.
     */
    orderBy?: ItemBatchOrderByWithRelationInput | ItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemBatches
    **/
    _count?: true | ItemBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemBatchMaxAggregateInputType
  }

  export type GetItemBatchAggregateType<T extends ItemBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateItemBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemBatch[P]>
      : GetScalarType<T[P], AggregateItemBatch[P]>
  }




  export type ItemBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemBatchWhereInput
    orderBy?: ItemBatchOrderByWithAggregationInput | ItemBatchOrderByWithAggregationInput[]
    by: ItemBatchScalarFieldEnum[] | ItemBatchScalarFieldEnum
    having?: ItemBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemBatchCountAggregateInputType | true
    _avg?: ItemBatchAvgAggregateInputType
    _sum?: ItemBatchSumAggregateInputType
    _min?: ItemBatchMinAggregateInputType
    _max?: ItemBatchMaxAggregateInputType
  }

  export type ItemBatchGroupByOutputType = {
    id: string
    itemId: string
    batchCode: string
    expirationDate: Date | null
    unitCost: Decimal
    quantityAvailable: Decimal
    createdAt: Date
    _count: ItemBatchCountAggregateOutputType | null
    _avg: ItemBatchAvgAggregateOutputType | null
    _sum: ItemBatchSumAggregateOutputType | null
    _min: ItemBatchMinAggregateOutputType | null
    _max: ItemBatchMaxAggregateOutputType | null
  }

  type GetItemBatchGroupByPayload<T extends ItemBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemBatchGroupByOutputType[P]>
            : GetScalarType<T[P], ItemBatchGroupByOutputType[P]>
        }
      >
    >


  export type ItemBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchCode?: boolean
    expirationDate?: boolean
    unitCost?: boolean
    quantityAvailable?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    movements?: boolean | ItemBatch$movementsArgs<ExtArgs>
    _count?: boolean | ItemBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemBatch"]>

  export type ItemBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchCode?: boolean
    expirationDate?: boolean
    unitCost?: boolean
    quantityAvailable?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemBatch"]>

  export type ItemBatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchCode?: boolean
    expirationDate?: boolean
    unitCost?: boolean
    quantityAvailable?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemBatch"]>

  export type ItemBatchSelectScalar = {
    id?: boolean
    itemId?: boolean
    batchCode?: boolean
    expirationDate?: boolean
    unitCost?: boolean
    quantityAvailable?: boolean
    createdAt?: boolean
  }

  export type ItemBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "batchCode" | "expirationDate" | "unitCost" | "quantityAvailable" | "createdAt", ExtArgs["result"]["itemBatch"]>
  export type ItemBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    movements?: boolean | ItemBatch$movementsArgs<ExtArgs>
    _count?: boolean | ItemBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemBatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemBatch"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      batchCode: string
      expirationDate: Date | null
      unitCost: Prisma.Decimal
      quantityAvailable: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["itemBatch"]>
    composites: {}
  }

  type ItemBatchGetPayload<S extends boolean | null | undefined | ItemBatchDefaultArgs> = $Result.GetResult<Prisma.$ItemBatchPayload, S>

  type ItemBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemBatchCountAggregateInputType | true
    }

  export interface ItemBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemBatch'], meta: { name: 'ItemBatch' } }
    /**
     * Find zero or one ItemBatch that matches the filter.
     * @param {ItemBatchFindUniqueArgs} args - Arguments to find a ItemBatch
     * @example
     * // Get one ItemBatch
     * const itemBatch = await prisma.itemBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemBatchFindUniqueArgs>(args: SelectSubset<T, ItemBatchFindUniqueArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemBatchFindUniqueOrThrowArgs} args - Arguments to find a ItemBatch
     * @example
     * // Get one ItemBatch
     * const itemBatch = await prisma.itemBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchFindFirstArgs} args - Arguments to find a ItemBatch
     * @example
     * // Get one ItemBatch
     * const itemBatch = await prisma.itemBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemBatchFindFirstArgs>(args?: SelectSubset<T, ItemBatchFindFirstArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchFindFirstOrThrowArgs} args - Arguments to find a ItemBatch
     * @example
     * // Get one ItemBatch
     * const itemBatch = await prisma.itemBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemBatches
     * const itemBatches = await prisma.itemBatch.findMany()
     * 
     * // Get first 10 ItemBatches
     * const itemBatches = await prisma.itemBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemBatchWithIdOnly = await prisma.itemBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemBatchFindManyArgs>(args?: SelectSubset<T, ItemBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemBatch.
     * @param {ItemBatchCreateArgs} args - Arguments to create a ItemBatch.
     * @example
     * // Create one ItemBatch
     * const ItemBatch = await prisma.itemBatch.create({
     *   data: {
     *     // ... data to create a ItemBatch
     *   }
     * })
     * 
     */
    create<T extends ItemBatchCreateArgs>(args: SelectSubset<T, ItemBatchCreateArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemBatches.
     * @param {ItemBatchCreateManyArgs} args - Arguments to create many ItemBatches.
     * @example
     * // Create many ItemBatches
     * const itemBatch = await prisma.itemBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemBatchCreateManyArgs>(args?: SelectSubset<T, ItemBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemBatches and returns the data saved in the database.
     * @param {ItemBatchCreateManyAndReturnArgs} args - Arguments to create many ItemBatches.
     * @example
     * // Create many ItemBatches
     * const itemBatch = await prisma.itemBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemBatches and only return the `id`
     * const itemBatchWithIdOnly = await prisma.itemBatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemBatch.
     * @param {ItemBatchDeleteArgs} args - Arguments to delete one ItemBatch.
     * @example
     * // Delete one ItemBatch
     * const ItemBatch = await prisma.itemBatch.delete({
     *   where: {
     *     // ... filter to delete one ItemBatch
     *   }
     * })
     * 
     */
    delete<T extends ItemBatchDeleteArgs>(args: SelectSubset<T, ItemBatchDeleteArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemBatch.
     * @param {ItemBatchUpdateArgs} args - Arguments to update one ItemBatch.
     * @example
     * // Update one ItemBatch
     * const itemBatch = await prisma.itemBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemBatchUpdateArgs>(args: SelectSubset<T, ItemBatchUpdateArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemBatches.
     * @param {ItemBatchDeleteManyArgs} args - Arguments to filter ItemBatches to delete.
     * @example
     * // Delete a few ItemBatches
     * const { count } = await prisma.itemBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemBatchDeleteManyArgs>(args?: SelectSubset<T, ItemBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemBatches
     * const itemBatch = await prisma.itemBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemBatchUpdateManyArgs>(args: SelectSubset<T, ItemBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemBatches and returns the data updated in the database.
     * @param {ItemBatchUpdateManyAndReturnArgs} args - Arguments to update many ItemBatches.
     * @example
     * // Update many ItemBatches
     * const itemBatch = await prisma.itemBatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemBatches and only return the `id`
     * const itemBatchWithIdOnly = await prisma.itemBatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemBatchUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemBatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemBatch.
     * @param {ItemBatchUpsertArgs} args - Arguments to update or create a ItemBatch.
     * @example
     * // Update or create a ItemBatch
     * const itemBatch = await prisma.itemBatch.upsert({
     *   create: {
     *     // ... data to create a ItemBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemBatch we want to update
     *   }
     * })
     */
    upsert<T extends ItemBatchUpsertArgs>(args: SelectSubset<T, ItemBatchUpsertArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchCountArgs} args - Arguments to filter ItemBatches to count.
     * @example
     * // Count the number of ItemBatches
     * const count = await prisma.itemBatch.count({
     *   where: {
     *     // ... the filter for the ItemBatches we want to count
     *   }
     * })
    **/
    count<T extends ItemBatchCountArgs>(
      args?: Subset<T, ItemBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemBatchAggregateArgs>(args: Subset<T, ItemBatchAggregateArgs>): Prisma.PrismaPromise<GetItemBatchAggregateType<T>>

    /**
     * Group by ItemBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemBatchGroupByArgs['orderBy'] }
        : { orderBy?: ItemBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemBatch model
   */
  readonly fields: ItemBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movements<T extends ItemBatch$movementsArgs<ExtArgs> = {}>(args?: Subset<T, ItemBatch$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemBatch model
   */
  interface ItemBatchFieldRefs {
    readonly id: FieldRef<"ItemBatch", 'String'>
    readonly itemId: FieldRef<"ItemBatch", 'String'>
    readonly batchCode: FieldRef<"ItemBatch", 'String'>
    readonly expirationDate: FieldRef<"ItemBatch", 'DateTime'>
    readonly unitCost: FieldRef<"ItemBatch", 'Decimal'>
    readonly quantityAvailable: FieldRef<"ItemBatch", 'Decimal'>
    readonly createdAt: FieldRef<"ItemBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemBatch findUnique
   */
  export type ItemBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which ItemBatch to fetch.
     */
    where: ItemBatchWhereUniqueInput
  }

  /**
   * ItemBatch findUniqueOrThrow
   */
  export type ItemBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which ItemBatch to fetch.
     */
    where: ItemBatchWhereUniqueInput
  }

  /**
   * ItemBatch findFirst
   */
  export type ItemBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which ItemBatch to fetch.
     */
    where?: ItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBatches to fetch.
     */
    orderBy?: ItemBatchOrderByWithRelationInput | ItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemBatches.
     */
    cursor?: ItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemBatches.
     */
    distinct?: ItemBatchScalarFieldEnum | ItemBatchScalarFieldEnum[]
  }

  /**
   * ItemBatch findFirstOrThrow
   */
  export type ItemBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which ItemBatch to fetch.
     */
    where?: ItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBatches to fetch.
     */
    orderBy?: ItemBatchOrderByWithRelationInput | ItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemBatches.
     */
    cursor?: ItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemBatches.
     */
    distinct?: ItemBatchScalarFieldEnum | ItemBatchScalarFieldEnum[]
  }

  /**
   * ItemBatch findMany
   */
  export type ItemBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter, which ItemBatches to fetch.
     */
    where?: ItemBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBatches to fetch.
     */
    orderBy?: ItemBatchOrderByWithRelationInput | ItemBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemBatches.
     */
    cursor?: ItemBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBatches.
     */
    skip?: number
    distinct?: ItemBatchScalarFieldEnum | ItemBatchScalarFieldEnum[]
  }

  /**
   * ItemBatch create
   */
  export type ItemBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemBatch.
     */
    data: XOR<ItemBatchCreateInput, ItemBatchUncheckedCreateInput>
  }

  /**
   * ItemBatch createMany
   */
  export type ItemBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemBatches.
     */
    data: ItemBatchCreateManyInput | ItemBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemBatch createManyAndReturn
   */
  export type ItemBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * The data used to create many ItemBatches.
     */
    data: ItemBatchCreateManyInput | ItemBatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemBatch update
   */
  export type ItemBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemBatch.
     */
    data: XOR<ItemBatchUpdateInput, ItemBatchUncheckedUpdateInput>
    /**
     * Choose, which ItemBatch to update.
     */
    where: ItemBatchWhereUniqueInput
  }

  /**
   * ItemBatch updateMany
   */
  export type ItemBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemBatches.
     */
    data: XOR<ItemBatchUpdateManyMutationInput, ItemBatchUncheckedUpdateManyInput>
    /**
     * Filter which ItemBatches to update
     */
    where?: ItemBatchWhereInput
    /**
     * Limit how many ItemBatches to update.
     */
    limit?: number
  }

  /**
   * ItemBatch updateManyAndReturn
   */
  export type ItemBatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * The data used to update ItemBatches.
     */
    data: XOR<ItemBatchUpdateManyMutationInput, ItemBatchUncheckedUpdateManyInput>
    /**
     * Filter which ItemBatches to update
     */
    where?: ItemBatchWhereInput
    /**
     * Limit how many ItemBatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemBatch upsert
   */
  export type ItemBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemBatch to update in case it exists.
     */
    where: ItemBatchWhereUniqueInput
    /**
     * In case the ItemBatch found by the `where` argument doesn't exist, create a new ItemBatch with this data.
     */
    create: XOR<ItemBatchCreateInput, ItemBatchUncheckedCreateInput>
    /**
     * In case the ItemBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemBatchUpdateInput, ItemBatchUncheckedUpdateInput>
  }

  /**
   * ItemBatch delete
   */
  export type ItemBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    /**
     * Filter which ItemBatch to delete.
     */
    where: ItemBatchWhereUniqueInput
  }

  /**
   * ItemBatch deleteMany
   */
  export type ItemBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemBatches to delete
     */
    where?: ItemBatchWhereInput
    /**
     * Limit how many ItemBatches to delete.
     */
    limit?: number
  }

  /**
   * ItemBatch.movements
   */
  export type ItemBatch$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * ItemBatch without action
   */
  export type ItemBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    batchId: string | null
    type: $Enums.MovementType | null
    quantity: Decimal | null
    unitCost: Decimal | null
    reason: string | null
    linkedProcedureId: string | null
    performedByUserId: string | null
    createdAt: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    batchId: string | null
    type: $Enums.MovementType | null
    quantity: Decimal | null
    unitCost: Decimal | null
    reason: string | null
    linkedProcedureId: string | null
    performedByUserId: string | null
    createdAt: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    itemId: number
    batchId: number
    type: number
    quantity: number
    unitCost: number
    reason: number
    linkedProcedureId: number
    performedByUserId: number
    createdAt: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    itemId?: true
    batchId?: true
    type?: true
    quantity?: true
    unitCost?: true
    reason?: true
    linkedProcedureId?: true
    performedByUserId?: true
    createdAt?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    itemId?: true
    batchId?: true
    type?: true
    quantity?: true
    unitCost?: true
    reason?: true
    linkedProcedureId?: true
    performedByUserId?: true
    createdAt?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    itemId?: true
    batchId?: true
    type?: true
    quantity?: true
    unitCost?: true
    reason?: true
    linkedProcedureId?: true
    performedByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    itemId: string
    batchId: string | null
    type: $Enums.MovementType
    quantity: Decimal
    unitCost: Decimal | null
    reason: string | null
    linkedProcedureId: string | null
    performedByUserId: string
    createdAt: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    reason?: boolean
    linkedProcedureId?: boolean
    performedByUserId?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    reason?: boolean
    linkedProcedureId?: boolean
    performedByUserId?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    batchId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    reason?: boolean
    linkedProcedureId?: boolean
    performedByUserId?: boolean
    createdAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    itemId?: boolean
    batchId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    reason?: boolean
    linkedProcedureId?: boolean
    performedByUserId?: boolean
    createdAt?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "batchId" | "type" | "quantity" | "unitCost" | "reason" | "linkedProcedureId" | "performedByUserId" | "createdAt", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    batch?: boolean | InventoryMovement$batchArgs<ExtArgs>
    performedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      batch: Prisma.$ItemBatchPayload<ExtArgs> | null
      performedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      batchId: string | null
      type: $Enums.MovementType
      quantity: Prisma.Decimal
      unitCost: Prisma.Decimal | null
      reason: string | null
      linkedProcedureId: string | null
      performedByUserId: string
      createdAt: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends InventoryMovement$batchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$batchArgs<ExtArgs>>): Prisma__ItemBatchClient<$Result.GetResult<Prisma.$ItemBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    performedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly itemId: FieldRef<"InventoryMovement", 'String'>
    readonly batchId: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'MovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Decimal'>
    readonly unitCost: FieldRef<"InventoryMovement", 'Decimal'>
    readonly reason: FieldRef<"InventoryMovement", 'String'>
    readonly linkedProcedureId: FieldRef<"InventoryMovement", 'String'>
    readonly performedByUserId: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement.batch
   */
  export type InventoryMovement$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBatch
     */
    select?: ItemBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemBatch
     */
    omit?: ItemBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemBatchInclude<ExtArgs> | null
    where?: ItemBatchWhereInput
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model ProcedureType
   */

  export type AggregateProcedureType = {
    _count: ProcedureTypeCountAggregateOutputType | null
    _avg: ProcedureTypeAvgAggregateOutputType | null
    _sum: ProcedureTypeSumAggregateOutputType | null
    _min: ProcedureTypeMinAggregateOutputType | null
    _max: ProcedureTypeMaxAggregateOutputType | null
  }

  export type ProcedureTypeAvgAggregateOutputType = {
    defaultDurationMin: number | null
  }

  export type ProcedureTypeSumAggregateOutputType = {
    defaultDurationMin: number | null
  }

  export type ProcedureTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    defaultDurationMin: number | null
  }

  export type ProcedureTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    defaultDurationMin: number | null
  }

  export type ProcedureTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    defaultDurationMin: number
    defaultItems: number
    _all: number
  }


  export type ProcedureTypeAvgAggregateInputType = {
    defaultDurationMin?: true
  }

  export type ProcedureTypeSumAggregateInputType = {
    defaultDurationMin?: true
  }

  export type ProcedureTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDurationMin?: true
  }

  export type ProcedureTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDurationMin?: true
  }

  export type ProcedureTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultDurationMin?: true
    defaultItems?: true
    _all?: true
  }

  export type ProcedureTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcedureType to aggregate.
     */
    where?: ProcedureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureTypes to fetch.
     */
    orderBy?: ProcedureTypeOrderByWithRelationInput | ProcedureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcedureTypes
    **/
    _count?: true | ProcedureTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedureTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedureTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureTypeMaxAggregateInputType
  }

  export type GetProcedureTypeAggregateType<T extends ProcedureTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedureType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedureType[P]>
      : GetScalarType<T[P], AggregateProcedureType[P]>
  }




  export type ProcedureTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureTypeWhereInput
    orderBy?: ProcedureTypeOrderByWithAggregationInput | ProcedureTypeOrderByWithAggregationInput[]
    by: ProcedureTypeScalarFieldEnum[] | ProcedureTypeScalarFieldEnum
    having?: ProcedureTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureTypeCountAggregateInputType | true
    _avg?: ProcedureTypeAvgAggregateInputType
    _sum?: ProcedureTypeSumAggregateInputType
    _min?: ProcedureTypeMinAggregateInputType
    _max?: ProcedureTypeMaxAggregateInputType
  }

  export type ProcedureTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    defaultDurationMin: number
    defaultItems: JsonValue
    _count: ProcedureTypeCountAggregateOutputType | null
    _avg: ProcedureTypeAvgAggregateOutputType | null
    _sum: ProcedureTypeSumAggregateOutputType | null
    _min: ProcedureTypeMinAggregateOutputType | null
    _max: ProcedureTypeMaxAggregateOutputType | null
  }

  type GetProcedureTypeGroupByPayload<T extends ProcedureTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDurationMin?: boolean
    defaultItems?: boolean
    procedures?: boolean | ProcedureType$proceduresArgs<ExtArgs>
    _count?: boolean | ProcedureTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedureType"]>

  export type ProcedureTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDurationMin?: boolean
    defaultItems?: boolean
  }, ExtArgs["result"]["procedureType"]>

  export type ProcedureTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDurationMin?: boolean
    defaultItems?: boolean
  }, ExtArgs["result"]["procedureType"]>

  export type ProcedureTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    defaultDurationMin?: boolean
    defaultItems?: boolean
  }

  export type ProcedureTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "defaultDurationMin" | "defaultItems", ExtArgs["result"]["procedureType"]>
  export type ProcedureTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedures?: boolean | ProcedureType$proceduresArgs<ExtArgs>
    _count?: boolean | ProcedureTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProcedureTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProcedureTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcedureType"
    objects: {
      procedures: Prisma.$ProcedurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      defaultDurationMin: number
      defaultItems: Prisma.JsonValue
    }, ExtArgs["result"]["procedureType"]>
    composites: {}
  }

  type ProcedureTypeGetPayload<S extends boolean | null | undefined | ProcedureTypeDefaultArgs> = $Result.GetResult<Prisma.$ProcedureTypePayload, S>

  type ProcedureTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcedureTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcedureTypeCountAggregateInputType | true
    }

  export interface ProcedureTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcedureType'], meta: { name: 'ProcedureType' } }
    /**
     * Find zero or one ProcedureType that matches the filter.
     * @param {ProcedureTypeFindUniqueArgs} args - Arguments to find a ProcedureType
     * @example
     * // Get one ProcedureType
     * const procedureType = await prisma.procedureType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureTypeFindUniqueArgs>(args: SelectSubset<T, ProcedureTypeFindUniqueArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcedureType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcedureTypeFindUniqueOrThrowArgs} args - Arguments to find a ProcedureType
     * @example
     * // Get one ProcedureType
     * const procedureType = await prisma.procedureType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcedureType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeFindFirstArgs} args - Arguments to find a ProcedureType
     * @example
     * // Get one ProcedureType
     * const procedureType = await prisma.procedureType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureTypeFindFirstArgs>(args?: SelectSubset<T, ProcedureTypeFindFirstArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcedureType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeFindFirstOrThrowArgs} args - Arguments to find a ProcedureType
     * @example
     * // Get one ProcedureType
     * const procedureType = await prisma.procedureType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcedureTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcedureTypes
     * const procedureTypes = await prisma.procedureType.findMany()
     * 
     * // Get first 10 ProcedureTypes
     * const procedureTypes = await prisma.procedureType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedureTypeWithIdOnly = await prisma.procedureType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcedureTypeFindManyArgs>(args?: SelectSubset<T, ProcedureTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcedureType.
     * @param {ProcedureTypeCreateArgs} args - Arguments to create a ProcedureType.
     * @example
     * // Create one ProcedureType
     * const ProcedureType = await prisma.procedureType.create({
     *   data: {
     *     // ... data to create a ProcedureType
     *   }
     * })
     * 
     */
    create<T extends ProcedureTypeCreateArgs>(args: SelectSubset<T, ProcedureTypeCreateArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcedureTypes.
     * @param {ProcedureTypeCreateManyArgs} args - Arguments to create many ProcedureTypes.
     * @example
     * // Create many ProcedureTypes
     * const procedureType = await prisma.procedureType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureTypeCreateManyArgs>(args?: SelectSubset<T, ProcedureTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcedureTypes and returns the data saved in the database.
     * @param {ProcedureTypeCreateManyAndReturnArgs} args - Arguments to create many ProcedureTypes.
     * @example
     * // Create many ProcedureTypes
     * const procedureType = await prisma.procedureType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcedureTypes and only return the `id`
     * const procedureTypeWithIdOnly = await prisma.procedureType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcedureType.
     * @param {ProcedureTypeDeleteArgs} args - Arguments to delete one ProcedureType.
     * @example
     * // Delete one ProcedureType
     * const ProcedureType = await prisma.procedureType.delete({
     *   where: {
     *     // ... filter to delete one ProcedureType
     *   }
     * })
     * 
     */
    delete<T extends ProcedureTypeDeleteArgs>(args: SelectSubset<T, ProcedureTypeDeleteArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcedureType.
     * @param {ProcedureTypeUpdateArgs} args - Arguments to update one ProcedureType.
     * @example
     * // Update one ProcedureType
     * const procedureType = await prisma.procedureType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureTypeUpdateArgs>(args: SelectSubset<T, ProcedureTypeUpdateArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcedureTypes.
     * @param {ProcedureTypeDeleteManyArgs} args - Arguments to filter ProcedureTypes to delete.
     * @example
     * // Delete a few ProcedureTypes
     * const { count } = await prisma.procedureType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureTypeDeleteManyArgs>(args?: SelectSubset<T, ProcedureTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcedureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcedureTypes
     * const procedureType = await prisma.procedureType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureTypeUpdateManyArgs>(args: SelectSubset<T, ProcedureTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcedureTypes and returns the data updated in the database.
     * @param {ProcedureTypeUpdateManyAndReturnArgs} args - Arguments to update many ProcedureTypes.
     * @example
     * // Update many ProcedureTypes
     * const procedureType = await prisma.procedureType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcedureTypes and only return the `id`
     * const procedureTypeWithIdOnly = await prisma.procedureType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcedureTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcedureTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcedureType.
     * @param {ProcedureTypeUpsertArgs} args - Arguments to update or create a ProcedureType.
     * @example
     * // Update or create a ProcedureType
     * const procedureType = await prisma.procedureType.upsert({
     *   create: {
     *     // ... data to create a ProcedureType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcedureType we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureTypeUpsertArgs>(args: SelectSubset<T, ProcedureTypeUpsertArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcedureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeCountArgs} args - Arguments to filter ProcedureTypes to count.
     * @example
     * // Count the number of ProcedureTypes
     * const count = await prisma.procedureType.count({
     *   where: {
     *     // ... the filter for the ProcedureTypes we want to count
     *   }
     * })
    **/
    count<T extends ProcedureTypeCountArgs>(
      args?: Subset<T, ProcedureTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcedureType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureTypeAggregateArgs>(args: Subset<T, ProcedureTypeAggregateArgs>): Prisma.PrismaPromise<GetProcedureTypeAggregateType<T>>

    /**
     * Group by ProcedureType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcedureType model
   */
  readonly fields: ProcedureTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcedureType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedures<T extends ProcedureType$proceduresArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureType$proceduresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcedureType model
   */
  interface ProcedureTypeFieldRefs {
    readonly id: FieldRef<"ProcedureType", 'String'>
    readonly name: FieldRef<"ProcedureType", 'String'>
    readonly description: FieldRef<"ProcedureType", 'String'>
    readonly defaultDurationMin: FieldRef<"ProcedureType", 'Int'>
    readonly defaultItems: FieldRef<"ProcedureType", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ProcedureType findUnique
   */
  export type ProcedureTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureType to fetch.
     */
    where: ProcedureTypeWhereUniqueInput
  }

  /**
   * ProcedureType findUniqueOrThrow
   */
  export type ProcedureTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureType to fetch.
     */
    where: ProcedureTypeWhereUniqueInput
  }

  /**
   * ProcedureType findFirst
   */
  export type ProcedureTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureType to fetch.
     */
    where?: ProcedureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureTypes to fetch.
     */
    orderBy?: ProcedureTypeOrderByWithRelationInput | ProcedureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcedureTypes.
     */
    cursor?: ProcedureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcedureTypes.
     */
    distinct?: ProcedureTypeScalarFieldEnum | ProcedureTypeScalarFieldEnum[]
  }

  /**
   * ProcedureType findFirstOrThrow
   */
  export type ProcedureTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureType to fetch.
     */
    where?: ProcedureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureTypes to fetch.
     */
    orderBy?: ProcedureTypeOrderByWithRelationInput | ProcedureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcedureTypes.
     */
    cursor?: ProcedureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcedureTypes.
     */
    distinct?: ProcedureTypeScalarFieldEnum | ProcedureTypeScalarFieldEnum[]
  }

  /**
   * ProcedureType findMany
   */
  export type ProcedureTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureTypes to fetch.
     */
    where?: ProcedureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureTypes to fetch.
     */
    orderBy?: ProcedureTypeOrderByWithRelationInput | ProcedureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcedureTypes.
     */
    cursor?: ProcedureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureTypes.
     */
    skip?: number
    distinct?: ProcedureTypeScalarFieldEnum | ProcedureTypeScalarFieldEnum[]
  }

  /**
   * ProcedureType create
   */
  export type ProcedureTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcedureType.
     */
    data: XOR<ProcedureTypeCreateInput, ProcedureTypeUncheckedCreateInput>
  }

  /**
   * ProcedureType createMany
   */
  export type ProcedureTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcedureTypes.
     */
    data: ProcedureTypeCreateManyInput | ProcedureTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcedureType createManyAndReturn
   */
  export type ProcedureTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProcedureTypes.
     */
    data: ProcedureTypeCreateManyInput | ProcedureTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcedureType update
   */
  export type ProcedureTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcedureType.
     */
    data: XOR<ProcedureTypeUpdateInput, ProcedureTypeUncheckedUpdateInput>
    /**
     * Choose, which ProcedureType to update.
     */
    where: ProcedureTypeWhereUniqueInput
  }

  /**
   * ProcedureType updateMany
   */
  export type ProcedureTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcedureTypes.
     */
    data: XOR<ProcedureTypeUpdateManyMutationInput, ProcedureTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProcedureTypes to update
     */
    where?: ProcedureTypeWhereInput
    /**
     * Limit how many ProcedureTypes to update.
     */
    limit?: number
  }

  /**
   * ProcedureType updateManyAndReturn
   */
  export type ProcedureTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProcedureTypes.
     */
    data: XOR<ProcedureTypeUpdateManyMutationInput, ProcedureTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProcedureTypes to update
     */
    where?: ProcedureTypeWhereInput
    /**
     * Limit how many ProcedureTypes to update.
     */
    limit?: number
  }

  /**
   * ProcedureType upsert
   */
  export type ProcedureTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcedureType to update in case it exists.
     */
    where: ProcedureTypeWhereUniqueInput
    /**
     * In case the ProcedureType found by the `where` argument doesn't exist, create a new ProcedureType with this data.
     */
    create: XOR<ProcedureTypeCreateInput, ProcedureTypeUncheckedCreateInput>
    /**
     * In case the ProcedureType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureTypeUpdateInput, ProcedureTypeUncheckedUpdateInput>
  }

  /**
   * ProcedureType delete
   */
  export type ProcedureTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
    /**
     * Filter which ProcedureType to delete.
     */
    where: ProcedureTypeWhereUniqueInput
  }

  /**
   * ProcedureType deleteMany
   */
  export type ProcedureTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcedureTypes to delete
     */
    where?: ProcedureTypeWhereInput
    /**
     * Limit how many ProcedureTypes to delete.
     */
    limit?: number
  }

  /**
   * ProcedureType.procedures
   */
  export type ProcedureType$proceduresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    cursor?: ProcedureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * ProcedureType without action
   */
  export type ProcedureTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureType
     */
    select?: ProcedureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcedureType
     */
    omit?: ProcedureTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureTypeInclude<ExtArgs> | null
  }


  /**
   * Model Procedure
   */

  export type AggregateProcedure = {
    _count: ProcedureCountAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  export type ProcedureMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    professionalUserId: string | null
    procedureTypeId: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    room: string | null
    status: $Enums.ProcedureStatus | null
    notes: string | null
  }

  export type ProcedureMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    professionalUserId: string | null
    procedureTypeId: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    room: string | null
    status: $Enums.ProcedureStatus | null
    notes: string | null
  }

  export type ProcedureCountAggregateOutputType = {
    id: number
    patientId: number
    professionalUserId: number
    procedureTypeId: number
    scheduledAt: number
    startedAt: number
    finishedAt: number
    room: number
    status: number
    notes: number
    _all: number
  }


  export type ProcedureMinAggregateInputType = {
    id?: true
    patientId?: true
    professionalUserId?: true
    procedureTypeId?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    room?: true
    status?: true
    notes?: true
  }

  export type ProcedureMaxAggregateInputType = {
    id?: true
    patientId?: true
    professionalUserId?: true
    procedureTypeId?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    room?: true
    status?: true
    notes?: true
  }

  export type ProcedureCountAggregateInputType = {
    id?: true
    patientId?: true
    professionalUserId?: true
    procedureTypeId?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    room?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type ProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedure to aggregate.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedures
    **/
    _count?: true | ProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureMaxAggregateInputType
  }

  export type GetProcedureAggregateType<T extends ProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedure[P]>
      : GetScalarType<T[P], AggregateProcedure[P]>
  }




  export type ProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithAggregationInput | ProcedureOrderByWithAggregationInput[]
    by: ProcedureScalarFieldEnum[] | ProcedureScalarFieldEnum
    having?: ProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureCountAggregateInputType | true
    _min?: ProcedureMinAggregateInputType
    _max?: ProcedureMaxAggregateInputType
  }

  export type ProcedureGroupByOutputType = {
    id: string
    patientId: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date
    startedAt: Date | null
    finishedAt: Date | null
    room: string | null
    status: $Enums.ProcedureStatus
    notes: string | null
    _count: ProcedureCountAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  type GetProcedureGroupByPayload<T extends ProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    professionalUserId?: boolean
    procedureTypeId?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    room?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
    costSheet?: boolean | Procedure$costSheetArgs<ExtArgs>
    payments?: boolean | Procedure$paymentsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    professionalUserId?: boolean
    procedureTypeId?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    room?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    professionalUserId?: boolean
    procedureTypeId?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    room?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectScalar = {
    id?: boolean
    patientId?: boolean
    professionalUserId?: boolean
    procedureTypeId?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    room?: boolean
    status?: boolean
    notes?: boolean
  }

  export type ProcedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "professionalUserId" | "procedureTypeId" | "scheduledAt" | "startedAt" | "finishedAt" | "room" | "status" | "notes", ExtArgs["result"]["procedure"]>
  export type ProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
    costSheet?: boolean | Procedure$costSheetArgs<ExtArgs>
    payments?: boolean | Procedure$paymentsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
    procedureType?: boolean | ProcedureTypeDefaultArgs<ExtArgs>
  }

  export type $ProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedure"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      professional: Prisma.$UserPayload<ExtArgs>
      procedureType: Prisma.$ProcedureTypePayload<ExtArgs>
      costSheet: Prisma.$CostSheetPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      professionalUserId: string
      procedureTypeId: string
      scheduledAt: Date
      startedAt: Date | null
      finishedAt: Date | null
      room: string | null
      status: $Enums.ProcedureStatus
      notes: string | null
    }, ExtArgs["result"]["procedure"]>
    composites: {}
  }

  type ProcedureGetPayload<S extends boolean | null | undefined | ProcedureDefaultArgs> = $Result.GetResult<Prisma.$ProcedurePayload, S>

  type ProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcedureCountAggregateInputType | true
    }

  export interface ProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedure'], meta: { name: 'Procedure' } }
    /**
     * Find zero or one Procedure that matches the filter.
     * @param {ProcedureFindUniqueArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureFindUniqueArgs>(args: SelectSubset<T, ProcedureFindUniqueArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Procedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcedureFindUniqueOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureFindFirstArgs>(args?: SelectSubset<T, ProcedureFindFirstArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedures
     * const procedures = await prisma.procedure.findMany()
     * 
     * // Get first 10 Procedures
     * const procedures = await prisma.procedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedureWithIdOnly = await prisma.procedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcedureFindManyArgs>(args?: SelectSubset<T, ProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Procedure.
     * @param {ProcedureCreateArgs} args - Arguments to create a Procedure.
     * @example
     * // Create one Procedure
     * const Procedure = await prisma.procedure.create({
     *   data: {
     *     // ... data to create a Procedure
     *   }
     * })
     * 
     */
    create<T extends ProcedureCreateArgs>(args: SelectSubset<T, ProcedureCreateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Procedures.
     * @param {ProcedureCreateManyArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureCreateManyArgs>(args?: SelectSubset<T, ProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedures and returns the data saved in the database.
     * @param {ProcedureCreateManyAndReturnArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Procedure.
     * @param {ProcedureDeleteArgs} args - Arguments to delete one Procedure.
     * @example
     * // Delete one Procedure
     * const Procedure = await prisma.procedure.delete({
     *   where: {
     *     // ... filter to delete one Procedure
     *   }
     * })
     * 
     */
    delete<T extends ProcedureDeleteArgs>(args: SelectSubset<T, ProcedureDeleteArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Procedure.
     * @param {ProcedureUpdateArgs} args - Arguments to update one Procedure.
     * @example
     * // Update one Procedure
     * const procedure = await prisma.procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureUpdateArgs>(args: SelectSubset<T, ProcedureUpdateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Procedures.
     * @param {ProcedureDeleteManyArgs} args - Arguments to filter Procedures to delete.
     * @example
     * // Delete a few Procedures
     * const { count } = await prisma.procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureDeleteManyArgs>(args?: SelectSubset<T, ProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureUpdateManyArgs>(args: SelectSubset<T, ProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures and returns the data updated in the database.
     * @param {ProcedureUpdateManyAndReturnArgs} args - Arguments to update many Procedures.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Procedures and only return the `id`
     * const procedureWithIdOnly = await prisma.procedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcedureUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Procedure.
     * @param {ProcedureUpsertArgs} args - Arguments to update or create a Procedure.
     * @example
     * // Update or create a Procedure
     * const procedure = await prisma.procedure.upsert({
     *   create: {
     *     // ... data to create a Procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedure we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureUpsertArgs>(args: SelectSubset<T, ProcedureUpsertArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureCountArgs} args - Arguments to filter Procedures to count.
     * @example
     * // Count the number of Procedures
     * const count = await prisma.procedure.count({
     *   where: {
     *     // ... the filter for the Procedures we want to count
     *   }
     * })
    **/
    count<T extends ProcedureCountArgs>(
      args?: Subset<T, ProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureAggregateArgs>(args: Subset<T, ProcedureAggregateArgs>): Prisma.PrismaPromise<GetProcedureAggregateType<T>>

    /**
     * Group by Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedure model
   */
  readonly fields: ProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procedureType<T extends ProcedureTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureTypeDefaultArgs<ExtArgs>>): Prisma__ProcedureTypeClient<$Result.GetResult<Prisma.$ProcedureTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    costSheet<T extends Procedure$costSheetArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$costSheetArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Procedure$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedure model
   */
  interface ProcedureFieldRefs {
    readonly id: FieldRef<"Procedure", 'String'>
    readonly patientId: FieldRef<"Procedure", 'String'>
    readonly professionalUserId: FieldRef<"Procedure", 'String'>
    readonly procedureTypeId: FieldRef<"Procedure", 'String'>
    readonly scheduledAt: FieldRef<"Procedure", 'DateTime'>
    readonly startedAt: FieldRef<"Procedure", 'DateTime'>
    readonly finishedAt: FieldRef<"Procedure", 'DateTime'>
    readonly room: FieldRef<"Procedure", 'String'>
    readonly status: FieldRef<"Procedure", 'ProcedureStatus'>
    readonly notes: FieldRef<"Procedure", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Procedure findUnique
   */
  export type ProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findUniqueOrThrow
   */
  export type ProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findFirst
   */
  export type ProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findFirstOrThrow
   */
  export type ProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findMany
   */
  export type ProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedures to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure create
   */
  export type ProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedure.
     */
    data: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
  }

  /**
   * Procedure createMany
   */
  export type ProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure createManyAndReturn
   */
  export type ProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure update
   */
  export type ProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedure.
     */
    data: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
    /**
     * Choose, which Procedure to update.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure updateMany
   */
  export type ProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
  }

  /**
   * Procedure updateManyAndReturn
   */
  export type ProcedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Procedure upsert
   */
  export type ProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedure to update in case it exists.
     */
    where: ProcedureWhereUniqueInput
    /**
     * In case the Procedure found by the `where` argument doesn't exist, create a new Procedure with this data.
     */
    create: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
    /**
     * In case the Procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
  }

  /**
   * Procedure delete
   */
  export type ProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter which Procedure to delete.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure deleteMany
   */
  export type ProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedures to delete
     */
    where?: ProcedureWhereInput
    /**
     * Limit how many Procedures to delete.
     */
    limit?: number
  }

  /**
   * Procedure.costSheet
   */
  export type Procedure$costSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    where?: CostSheetWhereInput
  }

  /**
   * Procedure.payments
   */
  export type Procedure$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Procedure without action
   */
  export type ProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Procedure
     */
    omit?: ProcedureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
  }


  /**
   * Model CostSheet
   */

  export type AggregateCostSheet = {
    _count: CostSheetCountAggregateOutputType | null
    _avg: CostSheetAvgAggregateOutputType | null
    _sum: CostSheetSumAggregateOutputType | null
    _min: CostSheetMinAggregateOutputType | null
    _max: CostSheetMaxAggregateOutputType | null
  }

  export type CostSheetAvgAggregateOutputType = {
    itemsCost: Decimal | null
    laborCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    marginTarget: Decimal | null
    suggestedPrice: Decimal | null
  }

  export type CostSheetSumAggregateOutputType = {
    itemsCost: Decimal | null
    laborCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    marginTarget: Decimal | null
    suggestedPrice: Decimal | null
  }

  export type CostSheetMinAggregateOutputType = {
    id: string | null
    procedureId: string | null
    itemsCost: Decimal | null
    laborCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    marginTarget: Decimal | null
    suggestedPrice: Decimal | null
    createdAt: Date | null
  }

  export type CostSheetMaxAggregateOutputType = {
    id: string | null
    procedureId: string | null
    itemsCost: Decimal | null
    laborCost: Decimal | null
    overheadCost: Decimal | null
    totalCost: Decimal | null
    marginTarget: Decimal | null
    suggestedPrice: Decimal | null
    createdAt: Date | null
  }

  export type CostSheetCountAggregateOutputType = {
    id: number
    procedureId: number
    itemsCost: number
    laborCost: number
    overheadCost: number
    totalCost: number
    marginTarget: number
    suggestedPrice: number
    createdAt: number
    _all: number
  }


  export type CostSheetAvgAggregateInputType = {
    itemsCost?: true
    laborCost?: true
    overheadCost?: true
    totalCost?: true
    marginTarget?: true
    suggestedPrice?: true
  }

  export type CostSheetSumAggregateInputType = {
    itemsCost?: true
    laborCost?: true
    overheadCost?: true
    totalCost?: true
    marginTarget?: true
    suggestedPrice?: true
  }

  export type CostSheetMinAggregateInputType = {
    id?: true
    procedureId?: true
    itemsCost?: true
    laborCost?: true
    overheadCost?: true
    totalCost?: true
    marginTarget?: true
    suggestedPrice?: true
    createdAt?: true
  }

  export type CostSheetMaxAggregateInputType = {
    id?: true
    procedureId?: true
    itemsCost?: true
    laborCost?: true
    overheadCost?: true
    totalCost?: true
    marginTarget?: true
    suggestedPrice?: true
    createdAt?: true
  }

  export type CostSheetCountAggregateInputType = {
    id?: true
    procedureId?: true
    itemsCost?: true
    laborCost?: true
    overheadCost?: true
    totalCost?: true
    marginTarget?: true
    suggestedPrice?: true
    createdAt?: true
    _all?: true
  }

  export type CostSheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostSheet to aggregate.
     */
    where?: CostSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostSheets to fetch.
     */
    orderBy?: CostSheetOrderByWithRelationInput | CostSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostSheets
    **/
    _count?: true | CostSheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostSheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostSheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostSheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostSheetMaxAggregateInputType
  }

  export type GetCostSheetAggregateType<T extends CostSheetAggregateArgs> = {
        [P in keyof T & keyof AggregateCostSheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostSheet[P]>
      : GetScalarType<T[P], AggregateCostSheet[P]>
  }




  export type CostSheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostSheetWhereInput
    orderBy?: CostSheetOrderByWithAggregationInput | CostSheetOrderByWithAggregationInput[]
    by: CostSheetScalarFieldEnum[] | CostSheetScalarFieldEnum
    having?: CostSheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostSheetCountAggregateInputType | true
    _avg?: CostSheetAvgAggregateInputType
    _sum?: CostSheetSumAggregateInputType
    _min?: CostSheetMinAggregateInputType
    _max?: CostSheetMaxAggregateInputType
  }

  export type CostSheetGroupByOutputType = {
    id: string
    procedureId: string
    itemsCost: Decimal
    laborCost: Decimal
    overheadCost: Decimal
    totalCost: Decimal
    marginTarget: Decimal
    suggestedPrice: Decimal
    createdAt: Date
    _count: CostSheetCountAggregateOutputType | null
    _avg: CostSheetAvgAggregateOutputType | null
    _sum: CostSheetSumAggregateOutputType | null
    _min: CostSheetMinAggregateOutputType | null
    _max: CostSheetMaxAggregateOutputType | null
  }

  type GetCostSheetGroupByPayload<T extends CostSheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostSheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostSheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostSheetGroupByOutputType[P]>
            : GetScalarType<T[P], CostSheetGroupByOutputType[P]>
        }
      >
    >


  export type CostSheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    itemsCost?: boolean
    laborCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    marginTarget?: boolean
    suggestedPrice?: boolean
    createdAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costSheet"]>

  export type CostSheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    itemsCost?: boolean
    laborCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    marginTarget?: boolean
    suggestedPrice?: boolean
    createdAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costSheet"]>

  export type CostSheetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    itemsCost?: boolean
    laborCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    marginTarget?: boolean
    suggestedPrice?: boolean
    createdAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costSheet"]>

  export type CostSheetSelectScalar = {
    id?: boolean
    procedureId?: boolean
    itemsCost?: boolean
    laborCost?: boolean
    overheadCost?: boolean
    totalCost?: boolean
    marginTarget?: boolean
    suggestedPrice?: boolean
    createdAt?: boolean
  }

  export type CostSheetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "procedureId" | "itemsCost" | "laborCost" | "overheadCost" | "totalCost" | "marginTarget" | "suggestedPrice" | "createdAt", ExtArgs["result"]["costSheet"]>
  export type CostSheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type CostSheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type CostSheetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }

  export type $CostSheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostSheet"
    objects: {
      procedure: Prisma.$ProcedurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procedureId: string
      itemsCost: Prisma.Decimal
      laborCost: Prisma.Decimal
      overheadCost: Prisma.Decimal
      totalCost: Prisma.Decimal
      marginTarget: Prisma.Decimal
      suggestedPrice: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["costSheet"]>
    composites: {}
  }

  type CostSheetGetPayload<S extends boolean | null | undefined | CostSheetDefaultArgs> = $Result.GetResult<Prisma.$CostSheetPayload, S>

  type CostSheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostSheetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostSheetCountAggregateInputType | true
    }

  export interface CostSheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostSheet'], meta: { name: 'CostSheet' } }
    /**
     * Find zero or one CostSheet that matches the filter.
     * @param {CostSheetFindUniqueArgs} args - Arguments to find a CostSheet
     * @example
     * // Get one CostSheet
     * const costSheet = await prisma.costSheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostSheetFindUniqueArgs>(args: SelectSubset<T, CostSheetFindUniqueArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostSheet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostSheetFindUniqueOrThrowArgs} args - Arguments to find a CostSheet
     * @example
     * // Get one CostSheet
     * const costSheet = await prisma.costSheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostSheetFindUniqueOrThrowArgs>(args: SelectSubset<T, CostSheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostSheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetFindFirstArgs} args - Arguments to find a CostSheet
     * @example
     * // Get one CostSheet
     * const costSheet = await prisma.costSheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostSheetFindFirstArgs>(args?: SelectSubset<T, CostSheetFindFirstArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostSheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetFindFirstOrThrowArgs} args - Arguments to find a CostSheet
     * @example
     * // Get one CostSheet
     * const costSheet = await prisma.costSheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostSheetFindFirstOrThrowArgs>(args?: SelectSubset<T, CostSheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostSheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostSheets
     * const costSheets = await prisma.costSheet.findMany()
     * 
     * // Get first 10 CostSheets
     * const costSheets = await prisma.costSheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costSheetWithIdOnly = await prisma.costSheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostSheetFindManyArgs>(args?: SelectSubset<T, CostSheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostSheet.
     * @param {CostSheetCreateArgs} args - Arguments to create a CostSheet.
     * @example
     * // Create one CostSheet
     * const CostSheet = await prisma.costSheet.create({
     *   data: {
     *     // ... data to create a CostSheet
     *   }
     * })
     * 
     */
    create<T extends CostSheetCreateArgs>(args: SelectSubset<T, CostSheetCreateArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostSheets.
     * @param {CostSheetCreateManyArgs} args - Arguments to create many CostSheets.
     * @example
     * // Create many CostSheets
     * const costSheet = await prisma.costSheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostSheetCreateManyArgs>(args?: SelectSubset<T, CostSheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostSheets and returns the data saved in the database.
     * @param {CostSheetCreateManyAndReturnArgs} args - Arguments to create many CostSheets.
     * @example
     * // Create many CostSheets
     * const costSheet = await prisma.costSheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostSheets and only return the `id`
     * const costSheetWithIdOnly = await prisma.costSheet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostSheetCreateManyAndReturnArgs>(args?: SelectSubset<T, CostSheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostSheet.
     * @param {CostSheetDeleteArgs} args - Arguments to delete one CostSheet.
     * @example
     * // Delete one CostSheet
     * const CostSheet = await prisma.costSheet.delete({
     *   where: {
     *     // ... filter to delete one CostSheet
     *   }
     * })
     * 
     */
    delete<T extends CostSheetDeleteArgs>(args: SelectSubset<T, CostSheetDeleteArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostSheet.
     * @param {CostSheetUpdateArgs} args - Arguments to update one CostSheet.
     * @example
     * // Update one CostSheet
     * const costSheet = await prisma.costSheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostSheetUpdateArgs>(args: SelectSubset<T, CostSheetUpdateArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostSheets.
     * @param {CostSheetDeleteManyArgs} args - Arguments to filter CostSheets to delete.
     * @example
     * // Delete a few CostSheets
     * const { count } = await prisma.costSheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostSheetDeleteManyArgs>(args?: SelectSubset<T, CostSheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostSheets
     * const costSheet = await prisma.costSheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostSheetUpdateManyArgs>(args: SelectSubset<T, CostSheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostSheets and returns the data updated in the database.
     * @param {CostSheetUpdateManyAndReturnArgs} args - Arguments to update many CostSheets.
     * @example
     * // Update many CostSheets
     * const costSheet = await prisma.costSheet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostSheets and only return the `id`
     * const costSheetWithIdOnly = await prisma.costSheet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostSheetUpdateManyAndReturnArgs>(args: SelectSubset<T, CostSheetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostSheet.
     * @param {CostSheetUpsertArgs} args - Arguments to update or create a CostSheet.
     * @example
     * // Update or create a CostSheet
     * const costSheet = await prisma.costSheet.upsert({
     *   create: {
     *     // ... data to create a CostSheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostSheet we want to update
     *   }
     * })
     */
    upsert<T extends CostSheetUpsertArgs>(args: SelectSubset<T, CostSheetUpsertArgs<ExtArgs>>): Prisma__CostSheetClient<$Result.GetResult<Prisma.$CostSheetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetCountArgs} args - Arguments to filter CostSheets to count.
     * @example
     * // Count the number of CostSheets
     * const count = await prisma.costSheet.count({
     *   where: {
     *     // ... the filter for the CostSheets we want to count
     *   }
     * })
    **/
    count<T extends CostSheetCountArgs>(
      args?: Subset<T, CostSheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostSheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostSheetAggregateArgs>(args: Subset<T, CostSheetAggregateArgs>): Prisma.PrismaPromise<GetCostSheetAggregateType<T>>

    /**
     * Group by CostSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostSheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostSheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostSheetGroupByArgs['orderBy'] }
        : { orderBy?: CostSheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostSheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostSheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostSheet model
   */
  readonly fields: CostSheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostSheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostSheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedure<T extends ProcedureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureDefaultArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostSheet model
   */
  interface CostSheetFieldRefs {
    readonly id: FieldRef<"CostSheet", 'String'>
    readonly procedureId: FieldRef<"CostSheet", 'String'>
    readonly itemsCost: FieldRef<"CostSheet", 'Decimal'>
    readonly laborCost: FieldRef<"CostSheet", 'Decimal'>
    readonly overheadCost: FieldRef<"CostSheet", 'Decimal'>
    readonly totalCost: FieldRef<"CostSheet", 'Decimal'>
    readonly marginTarget: FieldRef<"CostSheet", 'Decimal'>
    readonly suggestedPrice: FieldRef<"CostSheet", 'Decimal'>
    readonly createdAt: FieldRef<"CostSheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostSheet findUnique
   */
  export type CostSheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter, which CostSheet to fetch.
     */
    where: CostSheetWhereUniqueInput
  }

  /**
   * CostSheet findUniqueOrThrow
   */
  export type CostSheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter, which CostSheet to fetch.
     */
    where: CostSheetWhereUniqueInput
  }

  /**
   * CostSheet findFirst
   */
  export type CostSheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter, which CostSheet to fetch.
     */
    where?: CostSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostSheets to fetch.
     */
    orderBy?: CostSheetOrderByWithRelationInput | CostSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostSheets.
     */
    cursor?: CostSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostSheets.
     */
    distinct?: CostSheetScalarFieldEnum | CostSheetScalarFieldEnum[]
  }

  /**
   * CostSheet findFirstOrThrow
   */
  export type CostSheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter, which CostSheet to fetch.
     */
    where?: CostSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostSheets to fetch.
     */
    orderBy?: CostSheetOrderByWithRelationInput | CostSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostSheets.
     */
    cursor?: CostSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostSheets.
     */
    distinct?: CostSheetScalarFieldEnum | CostSheetScalarFieldEnum[]
  }

  /**
   * CostSheet findMany
   */
  export type CostSheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter, which CostSheets to fetch.
     */
    where?: CostSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostSheets to fetch.
     */
    orderBy?: CostSheetOrderByWithRelationInput | CostSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostSheets.
     */
    cursor?: CostSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostSheets.
     */
    skip?: number
    distinct?: CostSheetScalarFieldEnum | CostSheetScalarFieldEnum[]
  }

  /**
   * CostSheet create
   */
  export type CostSheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * The data needed to create a CostSheet.
     */
    data: XOR<CostSheetCreateInput, CostSheetUncheckedCreateInput>
  }

  /**
   * CostSheet createMany
   */
  export type CostSheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostSheets.
     */
    data: CostSheetCreateManyInput | CostSheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostSheet createManyAndReturn
   */
  export type CostSheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * The data used to create many CostSheets.
     */
    data: CostSheetCreateManyInput | CostSheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostSheet update
   */
  export type CostSheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * The data needed to update a CostSheet.
     */
    data: XOR<CostSheetUpdateInput, CostSheetUncheckedUpdateInput>
    /**
     * Choose, which CostSheet to update.
     */
    where: CostSheetWhereUniqueInput
  }

  /**
   * CostSheet updateMany
   */
  export type CostSheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostSheets.
     */
    data: XOR<CostSheetUpdateManyMutationInput, CostSheetUncheckedUpdateManyInput>
    /**
     * Filter which CostSheets to update
     */
    where?: CostSheetWhereInput
    /**
     * Limit how many CostSheets to update.
     */
    limit?: number
  }

  /**
   * CostSheet updateManyAndReturn
   */
  export type CostSheetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * The data used to update CostSheets.
     */
    data: XOR<CostSheetUpdateManyMutationInput, CostSheetUncheckedUpdateManyInput>
    /**
     * Filter which CostSheets to update
     */
    where?: CostSheetWhereInput
    /**
     * Limit how many CostSheets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostSheet upsert
   */
  export type CostSheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * The filter to search for the CostSheet to update in case it exists.
     */
    where: CostSheetWhereUniqueInput
    /**
     * In case the CostSheet found by the `where` argument doesn't exist, create a new CostSheet with this data.
     */
    create: XOR<CostSheetCreateInput, CostSheetUncheckedCreateInput>
    /**
     * In case the CostSheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostSheetUpdateInput, CostSheetUncheckedUpdateInput>
  }

  /**
   * CostSheet delete
   */
  export type CostSheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
    /**
     * Filter which CostSheet to delete.
     */
    where: CostSheetWhereUniqueInput
  }

  /**
   * CostSheet deleteMany
   */
  export type CostSheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostSheets to delete
     */
    where?: CostSheetWhereInput
    /**
     * Limit how many CostSheets to delete.
     */
    limit?: number
  }

  /**
   * CostSheet without action
   */
  export type CostSheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostSheet
     */
    select?: CostSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostSheet
     */
    omit?: CostSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostSheetInclude<ExtArgs> | null
  }


  /**
   * Model PriceRule
   */

  export type AggregatePriceRule = {
    _count: PriceRuleCountAggregateOutputType | null
    _avg: PriceRuleAvgAggregateOutputType | null
    _sum: PriceRuleSumAggregateOutputType | null
    _min: PriceRuleMinAggregateOutputType | null
    _max: PriceRuleMaxAggregateOutputType | null
  }

  export type PriceRuleAvgAggregateOutputType = {
    marginTarget: Decimal | null
    minMargin: Decimal | null
    maxMargin: Decimal | null
  }

  export type PriceRuleSumAggregateOutputType = {
    marginTarget: Decimal | null
    minMargin: Decimal | null
    maxMargin: Decimal | null
  }

  export type PriceRuleMinAggregateOutputType = {
    id: string | null
    scope: $Enums.PriceScope | null
    scopeId: string | null
    marginTarget: Decimal | null
    minMargin: Decimal | null
    maxMargin: Decimal | null
  }

  export type PriceRuleMaxAggregateOutputType = {
    id: string | null
    scope: $Enums.PriceScope | null
    scopeId: string | null
    marginTarget: Decimal | null
    minMargin: Decimal | null
    maxMargin: Decimal | null
  }

  export type PriceRuleCountAggregateOutputType = {
    id: number
    scope: number
    scopeId: number
    marginTarget: number
    minMargin: number
    maxMargin: number
    dynamicAdjustments: number
    _all: number
  }


  export type PriceRuleAvgAggregateInputType = {
    marginTarget?: true
    minMargin?: true
    maxMargin?: true
  }

  export type PriceRuleSumAggregateInputType = {
    marginTarget?: true
    minMargin?: true
    maxMargin?: true
  }

  export type PriceRuleMinAggregateInputType = {
    id?: true
    scope?: true
    scopeId?: true
    marginTarget?: true
    minMargin?: true
    maxMargin?: true
  }

  export type PriceRuleMaxAggregateInputType = {
    id?: true
    scope?: true
    scopeId?: true
    marginTarget?: true
    minMargin?: true
    maxMargin?: true
  }

  export type PriceRuleCountAggregateInputType = {
    id?: true
    scope?: true
    scopeId?: true
    marginTarget?: true
    minMargin?: true
    maxMargin?: true
    dynamicAdjustments?: true
    _all?: true
  }

  export type PriceRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceRule to aggregate.
     */
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     */
    orderBy?: PriceRuleOrderByWithRelationInput | PriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceRules
    **/
    _count?: true | PriceRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceRuleMaxAggregateInputType
  }

  export type GetPriceRuleAggregateType<T extends PriceRuleAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceRule[P]>
      : GetScalarType<T[P], AggregatePriceRule[P]>
  }




  export type PriceRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceRuleWhereInput
    orderBy?: PriceRuleOrderByWithAggregationInput | PriceRuleOrderByWithAggregationInput[]
    by: PriceRuleScalarFieldEnum[] | PriceRuleScalarFieldEnum
    having?: PriceRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceRuleCountAggregateInputType | true
    _avg?: PriceRuleAvgAggregateInputType
    _sum?: PriceRuleSumAggregateInputType
    _min?: PriceRuleMinAggregateInputType
    _max?: PriceRuleMaxAggregateInputType
  }

  export type PriceRuleGroupByOutputType = {
    id: string
    scope: $Enums.PriceScope
    scopeId: string | null
    marginTarget: Decimal
    minMargin: Decimal
    maxMargin: Decimal
    dynamicAdjustments: JsonValue | null
    _count: PriceRuleCountAggregateOutputType | null
    _avg: PriceRuleAvgAggregateOutputType | null
    _sum: PriceRuleSumAggregateOutputType | null
    _min: PriceRuleMinAggregateOutputType | null
    _max: PriceRuleMaxAggregateOutputType | null
  }

  type GetPriceRuleGroupByPayload<T extends PriceRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceRuleGroupByOutputType[P]>
            : GetScalarType<T[P], PriceRuleGroupByOutputType[P]>
        }
      >
    >


  export type PriceRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    scopeId?: boolean
    marginTarget?: boolean
    minMargin?: boolean
    maxMargin?: boolean
    dynamicAdjustments?: boolean
  }, ExtArgs["result"]["priceRule"]>

  export type PriceRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    scopeId?: boolean
    marginTarget?: boolean
    minMargin?: boolean
    maxMargin?: boolean
    dynamicAdjustments?: boolean
  }, ExtArgs["result"]["priceRule"]>

  export type PriceRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    scopeId?: boolean
    marginTarget?: boolean
    minMargin?: boolean
    maxMargin?: boolean
    dynamicAdjustments?: boolean
  }, ExtArgs["result"]["priceRule"]>

  export type PriceRuleSelectScalar = {
    id?: boolean
    scope?: boolean
    scopeId?: boolean
    marginTarget?: boolean
    minMargin?: boolean
    maxMargin?: boolean
    dynamicAdjustments?: boolean
  }

  export type PriceRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scope" | "scopeId" | "marginTarget" | "minMargin" | "maxMargin" | "dynamicAdjustments", ExtArgs["result"]["priceRule"]>

  export type $PriceRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scope: $Enums.PriceScope
      scopeId: string | null
      marginTarget: Prisma.Decimal
      minMargin: Prisma.Decimal
      maxMargin: Prisma.Decimal
      dynamicAdjustments: Prisma.JsonValue | null
    }, ExtArgs["result"]["priceRule"]>
    composites: {}
  }

  type PriceRuleGetPayload<S extends boolean | null | undefined | PriceRuleDefaultArgs> = $Result.GetResult<Prisma.$PriceRulePayload, S>

  type PriceRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceRuleCountAggregateInputType | true
    }

  export interface PriceRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceRule'], meta: { name: 'PriceRule' } }
    /**
     * Find zero or one PriceRule that matches the filter.
     * @param {PriceRuleFindUniqueArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceRuleFindUniqueArgs>(args: SelectSubset<T, PriceRuleFindUniqueArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceRuleFindUniqueOrThrowArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleFindFirstArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceRuleFindFirstArgs>(args?: SelectSubset<T, PriceRuleFindFirstArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleFindFirstOrThrowArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceRules
     * const priceRules = await prisma.priceRule.findMany()
     * 
     * // Get first 10 PriceRules
     * const priceRules = await prisma.priceRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceRuleWithIdOnly = await prisma.priceRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceRuleFindManyArgs>(args?: SelectSubset<T, PriceRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceRule.
     * @param {PriceRuleCreateArgs} args - Arguments to create a PriceRule.
     * @example
     * // Create one PriceRule
     * const PriceRule = await prisma.priceRule.create({
     *   data: {
     *     // ... data to create a PriceRule
     *   }
     * })
     * 
     */
    create<T extends PriceRuleCreateArgs>(args: SelectSubset<T, PriceRuleCreateArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceRules.
     * @param {PriceRuleCreateManyArgs} args - Arguments to create many PriceRules.
     * @example
     * // Create many PriceRules
     * const priceRule = await prisma.priceRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceRuleCreateManyArgs>(args?: SelectSubset<T, PriceRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceRules and returns the data saved in the database.
     * @param {PriceRuleCreateManyAndReturnArgs} args - Arguments to create many PriceRules.
     * @example
     * // Create many PriceRules
     * const priceRule = await prisma.priceRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceRules and only return the `id`
     * const priceRuleWithIdOnly = await prisma.priceRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceRule.
     * @param {PriceRuleDeleteArgs} args - Arguments to delete one PriceRule.
     * @example
     * // Delete one PriceRule
     * const PriceRule = await prisma.priceRule.delete({
     *   where: {
     *     // ... filter to delete one PriceRule
     *   }
     * })
     * 
     */
    delete<T extends PriceRuleDeleteArgs>(args: SelectSubset<T, PriceRuleDeleteArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceRule.
     * @param {PriceRuleUpdateArgs} args - Arguments to update one PriceRule.
     * @example
     * // Update one PriceRule
     * const priceRule = await prisma.priceRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceRuleUpdateArgs>(args: SelectSubset<T, PriceRuleUpdateArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceRules.
     * @param {PriceRuleDeleteManyArgs} args - Arguments to filter PriceRules to delete.
     * @example
     * // Delete a few PriceRules
     * const { count } = await prisma.priceRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceRuleDeleteManyArgs>(args?: SelectSubset<T, PriceRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceRules
     * const priceRule = await prisma.priceRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceRuleUpdateManyArgs>(args: SelectSubset<T, PriceRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceRules and returns the data updated in the database.
     * @param {PriceRuleUpdateManyAndReturnArgs} args - Arguments to update many PriceRules.
     * @example
     * // Update many PriceRules
     * const priceRule = await prisma.priceRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceRules and only return the `id`
     * const priceRuleWithIdOnly = await prisma.priceRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceRule.
     * @param {PriceRuleUpsertArgs} args - Arguments to update or create a PriceRule.
     * @example
     * // Update or create a PriceRule
     * const priceRule = await prisma.priceRule.upsert({
     *   create: {
     *     // ... data to create a PriceRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceRule we want to update
     *   }
     * })
     */
    upsert<T extends PriceRuleUpsertArgs>(args: SelectSubset<T, PriceRuleUpsertArgs<ExtArgs>>): Prisma__PriceRuleClient<$Result.GetResult<Prisma.$PriceRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleCountArgs} args - Arguments to filter PriceRules to count.
     * @example
     * // Count the number of PriceRules
     * const count = await prisma.priceRule.count({
     *   where: {
     *     // ... the filter for the PriceRules we want to count
     *   }
     * })
    **/
    count<T extends PriceRuleCountArgs>(
      args?: Subset<T, PriceRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceRuleAggregateArgs>(args: Subset<T, PriceRuleAggregateArgs>): Prisma.PrismaPromise<GetPriceRuleAggregateType<T>>

    /**
     * Group by PriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceRuleGroupByArgs['orderBy'] }
        : { orderBy?: PriceRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceRule model
   */
  readonly fields: PriceRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceRule model
   */
  interface PriceRuleFieldRefs {
    readonly id: FieldRef<"PriceRule", 'String'>
    readonly scope: FieldRef<"PriceRule", 'PriceScope'>
    readonly scopeId: FieldRef<"PriceRule", 'String'>
    readonly marginTarget: FieldRef<"PriceRule", 'Decimal'>
    readonly minMargin: FieldRef<"PriceRule", 'Decimal'>
    readonly maxMargin: FieldRef<"PriceRule", 'Decimal'>
    readonly dynamicAdjustments: FieldRef<"PriceRule", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PriceRule findUnique
   */
  export type PriceRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter, which PriceRule to fetch.
     */
    where: PriceRuleWhereUniqueInput
  }

  /**
   * PriceRule findUniqueOrThrow
   */
  export type PriceRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter, which PriceRule to fetch.
     */
    where: PriceRuleWhereUniqueInput
  }

  /**
   * PriceRule findFirst
   */
  export type PriceRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter, which PriceRule to fetch.
     */
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     */
    orderBy?: PriceRuleOrderByWithRelationInput | PriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceRules.
     */
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceRules.
     */
    distinct?: PriceRuleScalarFieldEnum | PriceRuleScalarFieldEnum[]
  }

  /**
   * PriceRule findFirstOrThrow
   */
  export type PriceRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter, which PriceRule to fetch.
     */
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     */
    orderBy?: PriceRuleOrderByWithRelationInput | PriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceRules.
     */
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceRules.
     */
    distinct?: PriceRuleScalarFieldEnum | PriceRuleScalarFieldEnum[]
  }

  /**
   * PriceRule findMany
   */
  export type PriceRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter, which PriceRules to fetch.
     */
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     */
    orderBy?: PriceRuleOrderByWithRelationInput | PriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceRules.
     */
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     */
    skip?: number
    distinct?: PriceRuleScalarFieldEnum | PriceRuleScalarFieldEnum[]
  }

  /**
   * PriceRule create
   */
  export type PriceRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * The data needed to create a PriceRule.
     */
    data: XOR<PriceRuleCreateInput, PriceRuleUncheckedCreateInput>
  }

  /**
   * PriceRule createMany
   */
  export type PriceRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceRules.
     */
    data: PriceRuleCreateManyInput | PriceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceRule createManyAndReturn
   */
  export type PriceRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * The data used to create many PriceRules.
     */
    data: PriceRuleCreateManyInput | PriceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceRule update
   */
  export type PriceRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * The data needed to update a PriceRule.
     */
    data: XOR<PriceRuleUpdateInput, PriceRuleUncheckedUpdateInput>
    /**
     * Choose, which PriceRule to update.
     */
    where: PriceRuleWhereUniqueInput
  }

  /**
   * PriceRule updateMany
   */
  export type PriceRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceRules.
     */
    data: XOR<PriceRuleUpdateManyMutationInput, PriceRuleUncheckedUpdateManyInput>
    /**
     * Filter which PriceRules to update
     */
    where?: PriceRuleWhereInput
    /**
     * Limit how many PriceRules to update.
     */
    limit?: number
  }

  /**
   * PriceRule updateManyAndReturn
   */
  export type PriceRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * The data used to update PriceRules.
     */
    data: XOR<PriceRuleUpdateManyMutationInput, PriceRuleUncheckedUpdateManyInput>
    /**
     * Filter which PriceRules to update
     */
    where?: PriceRuleWhereInput
    /**
     * Limit how many PriceRules to update.
     */
    limit?: number
  }

  /**
   * PriceRule upsert
   */
  export type PriceRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * The filter to search for the PriceRule to update in case it exists.
     */
    where: PriceRuleWhereUniqueInput
    /**
     * In case the PriceRule found by the `where` argument doesn't exist, create a new PriceRule with this data.
     */
    create: XOR<PriceRuleCreateInput, PriceRuleUncheckedCreateInput>
    /**
     * In case the PriceRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceRuleUpdateInput, PriceRuleUncheckedUpdateInput>
  }

  /**
   * PriceRule delete
   */
  export type PriceRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
    /**
     * Filter which PriceRule to delete.
     */
    where: PriceRuleWhereUniqueInput
  }

  /**
   * PriceRule deleteMany
   */
  export type PriceRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceRules to delete
     */
    where?: PriceRuleWhereInput
    /**
     * Limit how many PriceRules to delete.
     */
    limit?: number
  }

  /**
   * PriceRule without action
   */
  export type PriceRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceRule
     */
    select?: PriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceRule
     */
    omit?: PriceRuleOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    procedureId: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    paidAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    procedureId: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    paidAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    procedureId: number
    method: number
    amount: number
    status: number
    paidAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    procedureId?: true
    method?: true
    amount?: true
    status?: true
    paidAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    procedureId?: true
    method?: true
    amount?: true
    status?: true
    paidAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    procedureId?: true
    method?: true
    amount?: true
    status?: true
    paidAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    procedureId: string
    method: $Enums.PaymentMethod
    amount: Decimal
    status: $Enums.PaymentStatus
    paidAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procedureId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    procedureId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    paidAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "procedureId" | "method" | "amount" | "status" | "paidAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    procedure?: boolean | ProcedureDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      procedure: Prisma.$ProcedurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procedureId: string
      method: $Enums.PaymentMethod
      amount: Prisma.Decimal
      status: $Enums.PaymentStatus
      paidAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    procedure<T extends ProcedureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureDefaultArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly procedureId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userRole: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
    tenantId: string | null
    resourceType: string | null
    resourceId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    accessPurpose: string | null
    justification: string | null
    previousHash: string | null
    currentHash: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userRole: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
    tenantId: string | null
    resourceType: string | null
    resourceId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    accessPurpose: string | null
    justification: string | null
    previousHash: string | null
    currentHash: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userRole: number
    action: number
    entity: number
    entityId: number
    metadata: number
    createdAt: number
    tenantId: number
    resourceType: number
    resourceId: number
    description: number
    changes: number
    ipAddress: number
    userAgent: number
    accessPurpose: number
    justification: number
    previousHash: number
    currentHash: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userRole?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
    tenantId?: true
    resourceType?: true
    resourceId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    accessPurpose?: true
    justification?: true
    previousHash?: true
    currentHash?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userRole?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
    tenantId?: true
    resourceType?: true
    resourceId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    accessPurpose?: true
    justification?: true
    previousHash?: true
    currentHash?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userRole?: true
    action?: true
    entity?: true
    entityId?: true
    metadata?: true
    createdAt?: true
    tenantId?: true
    resourceType?: true
    resourceId?: true
    description?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    accessPurpose?: true
    justification?: true
    previousHash?: true
    currentHash?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    userName: string | null
    userRole: string | null
    action: string
    entity: string
    entityId: string
    metadata: JsonValue | null
    createdAt: Date
    tenantId: string | null
    resourceType: string | null
    resourceId: string | null
    description: string | null
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    accessPurpose: string | null
    justification: string | null
    previousHash: string | null
    currentHash: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenantId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    description?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    accessPurpose?: boolean
    justification?: boolean
    previousHash?: boolean
    currentHash?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenantId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    description?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    accessPurpose?: boolean
    justification?: boolean
    previousHash?: boolean
    currentHash?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenantId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    description?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    accessPurpose?: boolean
    justification?: boolean
    previousHash?: boolean
    currentHash?: boolean
    timestamp?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenantId?: boolean
    resourceType?: boolean
    resourceId?: boolean
    description?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    accessPurpose?: boolean
    justification?: boolean
    previousHash?: boolean
    currentHash?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "userRole" | "action" | "entity" | "entityId" | "metadata" | "createdAt" | "tenantId" | "resourceType" | "resourceId" | "description" | "changes" | "ipAddress" | "userAgent" | "accessPurpose" | "justification" | "previousHash" | "currentHash" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      userName: string | null
      userRole: string | null
      action: string
      entity: string
      entityId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      tenantId: string | null
      resourceType: string | null
      resourceId: string | null
      description: string | null
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      accessPurpose: string | null
      justification: string | null
      previousHash: string | null
      currentHash: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly userRole: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly accessPurpose: FieldRef<"AuditLog", 'String'>
    readonly justification: FieldRef<"AuditLog", 'String'>
    readonly previousHash: FieldRef<"AuditLog", 'String'>
    readonly currentHash: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ClinicalNote
   */

  export type AggregateClinicalNote = {
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  export type ClinicalNoteMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    content: string | null
    authorId: string | null
    signed: boolean | null
    signedAt: Date | null
  }

  export type ClinicalNoteMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    content: string | null
    authorId: string | null
    signed: boolean | null
    signedAt: Date | null
  }

  export type ClinicalNoteCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    content: number
    authorId: number
    signed: number
    signedAt: number
    _all: number
  }


  export type ClinicalNoteMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    content?: true
    authorId?: true
    signed?: true
    signedAt?: true
  }

  export type ClinicalNoteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    content?: true
    authorId?: true
    signed?: true
    signedAt?: true
  }

  export type ClinicalNoteCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    content?: true
    authorId?: true
    signed?: true
    signedAt?: true
    _all?: true
  }

  export type ClinicalNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNote to aggregate.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalNotes
    **/
    _count?: true | ClinicalNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type GetClinicalNoteAggregateType<T extends ClinicalNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalNote[P]>
      : GetScalarType<T[P], AggregateClinicalNote[P]>
  }




  export type ClinicalNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithAggregationInput | ClinicalNoteOrderByWithAggregationInput[]
    by: ClinicalNoteScalarFieldEnum[] | ClinicalNoteScalarFieldEnum
    having?: ClinicalNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalNoteCountAggregateInputType | true
    _min?: ClinicalNoteMinAggregateInputType
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type ClinicalNoteGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    content: string
    authorId: string
    signed: boolean
    signedAt: Date | null
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  type GetClinicalNoteGroupByPayload<T extends ClinicalNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    content?: boolean
    authorId?: boolean
    signed?: boolean
    signedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    content?: boolean
    authorId?: boolean
    signed?: boolean
    signedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    content?: boolean
    authorId?: boolean
    signed?: boolean
    signedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    content?: boolean
    authorId?: boolean
    signed?: boolean
    signedAt?: boolean
  }

  export type ClinicalNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "content" | "authorId" | "signed" | "signedAt", ExtArgs["result"]["clinicalNote"]>
  export type ClinicalNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ClinicalNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalNote"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      content: string
      authorId: string
      signed: boolean
      signedAt: Date | null
    }, ExtArgs["result"]["clinicalNote"]>
    composites: {}
  }

  type ClinicalNoteGetPayload<S extends boolean | null | undefined | ClinicalNoteDefaultArgs> = $Result.GetResult<Prisma.$ClinicalNotePayload, S>

  type ClinicalNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicalNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicalNoteCountAggregateInputType | true
    }

  export interface ClinicalNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalNote'], meta: { name: 'ClinicalNote' } }
    /**
     * Find zero or one ClinicalNote that matches the filter.
     * @param {ClinicalNoteFindUniqueArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalNoteFindUniqueArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicalNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicalNoteFindUniqueOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalNoteFindFirstArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicalNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany()
     * 
     * // Get first 10 ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalNoteFindManyArgs>(args?: SelectSubset<T, ClinicalNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicalNote.
     * @param {ClinicalNoteCreateArgs} args - Arguments to create a ClinicalNote.
     * @example
     * // Create one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.create({
     *   data: {
     *     // ... data to create a ClinicalNote
     *   }
     * })
     * 
     */
    create<T extends ClinicalNoteCreateArgs>(args: SelectSubset<T, ClinicalNoteCreateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicalNotes.
     * @param {ClinicalNoteCreateManyArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalNoteCreateManyArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalNotes and returns the data saved in the database.
     * @param {ClinicalNoteCreateManyAndReturnArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicalNote.
     * @param {ClinicalNoteDeleteArgs} args - Arguments to delete one ClinicalNote.
     * @example
     * // Delete one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.delete({
     *   where: {
     *     // ... filter to delete one ClinicalNote
     *   }
     * })
     * 
     */
    delete<T extends ClinicalNoteDeleteArgs>(args: SelectSubset<T, ClinicalNoteDeleteArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicalNote.
     * @param {ClinicalNoteUpdateArgs} args - Arguments to update one ClinicalNote.
     * @example
     * // Update one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalNoteUpdateArgs>(args: SelectSubset<T, ClinicalNoteUpdateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicalNotes.
     * @param {ClinicalNoteDeleteManyArgs} args - Arguments to filter ClinicalNotes to delete.
     * @example
     * // Delete a few ClinicalNotes
     * const { count } = await prisma.clinicalNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalNoteDeleteManyArgs>(args?: SelectSubset<T, ClinicalNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalNoteUpdateManyArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes and returns the data updated in the database.
     * @param {ClinicalNoteUpdateManyAndReturnArgs} args - Arguments to update many ClinicalNotes.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicalNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicalNote.
     * @param {ClinicalNoteUpsertArgs} args - Arguments to update or create a ClinicalNote.
     * @example
     * // Update or create a ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.upsert({
     *   create: {
     *     // ... data to create a ClinicalNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalNote we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalNoteUpsertArgs>(args: SelectSubset<T, ClinicalNoteUpsertArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteCountArgs} args - Arguments to filter ClinicalNotes to count.
     * @example
     * // Count the number of ClinicalNotes
     * const count = await prisma.clinicalNote.count({
     *   where: {
     *     // ... the filter for the ClinicalNotes we want to count
     *   }
     * })
    **/
    count<T extends ClinicalNoteCountArgs>(
      args?: Subset<T, ClinicalNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalNoteAggregateArgs>(args: Subset<T, ClinicalNoteAggregateArgs>): Prisma.PrismaPromise<GetClinicalNoteAggregateType<T>>

    /**
     * Group by ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalNoteGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalNote model
   */
  readonly fields: ClinicalNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalNote model
   */
  interface ClinicalNoteFieldRefs {
    readonly id: FieldRef<"ClinicalNote", 'String'>
    readonly createdAt: FieldRef<"ClinicalNote", 'DateTime'>
    readonly patientId: FieldRef<"ClinicalNote", 'String'>
    readonly content: FieldRef<"ClinicalNote", 'String'>
    readonly authorId: FieldRef<"ClinicalNote", 'String'>
    readonly signed: FieldRef<"ClinicalNote", 'Boolean'>
    readonly signedAt: FieldRef<"ClinicalNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalNote findUnique
   */
  export type ClinicalNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findUniqueOrThrow
   */
  export type ClinicalNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findFirst
   */
  export type ClinicalNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findFirstOrThrow
   */
  export type ClinicalNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findMany
   */
  export type ClinicalNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNotes to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote create
   */
  export type ClinicalNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalNote.
     */
    data: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
  }

  /**
   * ClinicalNote createMany
   */
  export type ClinicalNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalNote createManyAndReturn
   */
  export type ClinicalNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote update
   */
  export type ClinicalNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalNote.
     */
    data: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
    /**
     * Choose, which ClinicalNote to update.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote updateMany
   */
  export type ClinicalNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
  }

  /**
   * ClinicalNote updateManyAndReturn
   */
  export type ClinicalNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote upsert
   */
  export type ClinicalNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalNote to update in case it exists.
     */
    where: ClinicalNoteWhereUniqueInput
    /**
     * In case the ClinicalNote found by the `where` argument doesn't exist, create a new ClinicalNote with this data.
     */
    create: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
    /**
     * In case the ClinicalNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
  }

  /**
   * ClinicalNote delete
   */
  export type ClinicalNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter which ClinicalNote to delete.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote deleteMany
   */
  export type ClinicalNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNotes to delete
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to delete.
     */
    limit?: number
  }

  /**
   * ClinicalNote without action
   */
  export type ClinicalNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
  }


  /**
   * Model Observation
   */

  export type AggregateObservation = {
    _count: ObservationCountAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  export type ObservationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    value: string | null
    unit: string | null
  }

  export type ObservationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    value: string | null
    unit: string | null
  }

  export type ObservationCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    code: number
    value: number
    unit: number
    _all: number
  }


  export type ObservationMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    value?: true
    unit?: true
  }

  export type ObservationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    value?: true
    unit?: true
  }

  export type ObservationCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    value?: true
    unit?: true
    _all?: true
  }

  export type ObservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observation to aggregate.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Observations
    **/
    _count?: true | ObservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationMaxAggregateInputType
  }

  export type GetObservationAggregateType<T extends ObservationAggregateArgs> = {
        [P in keyof T & keyof AggregateObservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservation[P]>
      : GetScalarType<T[P], AggregateObservation[P]>
  }




  export type ObservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithAggregationInput | ObservationOrderByWithAggregationInput[]
    by: ObservationScalarFieldEnum[] | ObservationScalarFieldEnum
    having?: ObservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationCountAggregateInputType | true
    _min?: ObservationMinAggregateInputType
    _max?: ObservationMaxAggregateInputType
  }

  export type ObservationGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    code: string
    value: string
    unit: string | null
    _count: ObservationCountAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  type GetObservationGroupByPayload<T extends ObservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationGroupByOutputType[P]>
        }
      >
    >


  export type ObservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    value?: boolean
    unit?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    value?: boolean
    unit?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    value?: boolean
    unit?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    value?: boolean
    unit?: boolean
  }

  export type ObservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "code" | "value" | "unit", ExtArgs["result"]["observation"]>
  export type ObservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ObservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ObservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ObservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Observation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      code: string
      value: string
      unit: string | null
    }, ExtArgs["result"]["observation"]>
    composites: {}
  }

  type ObservationGetPayload<S extends boolean | null | undefined | ObservationDefaultArgs> = $Result.GetResult<Prisma.$ObservationPayload, S>

  type ObservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObservationCountAggregateInputType | true
    }

  export interface ObservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Observation'], meta: { name: 'Observation' } }
    /**
     * Find zero or one Observation that matches the filter.
     * @param {ObservationFindUniqueArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationFindUniqueArgs>(args: SelectSubset<T, ObservationFindUniqueArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Observation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObservationFindUniqueOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Observation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationFindFirstArgs>(args?: SelectSubset<T, ObservationFindFirstArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Observation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Observations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Observations
     * const observations = await prisma.observation.findMany()
     * 
     * // Get first 10 Observations
     * const observations = await prisma.observation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationWithIdOnly = await prisma.observation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationFindManyArgs>(args?: SelectSubset<T, ObservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Observation.
     * @param {ObservationCreateArgs} args - Arguments to create a Observation.
     * @example
     * // Create one Observation
     * const Observation = await prisma.observation.create({
     *   data: {
     *     // ... data to create a Observation
     *   }
     * })
     * 
     */
    create<T extends ObservationCreateArgs>(args: SelectSubset<T, ObservationCreateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Observations.
     * @param {ObservationCreateManyArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationCreateManyArgs>(args?: SelectSubset<T, ObservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Observations and returns the data saved in the database.
     * @param {ObservationCreateManyAndReturnArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Observations and only return the `id`
     * const observationWithIdOnly = await prisma.observation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Observation.
     * @param {ObservationDeleteArgs} args - Arguments to delete one Observation.
     * @example
     * // Delete one Observation
     * const Observation = await prisma.observation.delete({
     *   where: {
     *     // ... filter to delete one Observation
     *   }
     * })
     * 
     */
    delete<T extends ObservationDeleteArgs>(args: SelectSubset<T, ObservationDeleteArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Observation.
     * @param {ObservationUpdateArgs} args - Arguments to update one Observation.
     * @example
     * // Update one Observation
     * const observation = await prisma.observation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationUpdateArgs>(args: SelectSubset<T, ObservationUpdateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Observations.
     * @param {ObservationDeleteManyArgs} args - Arguments to filter Observations to delete.
     * @example
     * // Delete a few Observations
     * const { count } = await prisma.observation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationDeleteManyArgs>(args?: SelectSubset<T, ObservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationUpdateManyArgs>(args: SelectSubset<T, ObservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations and returns the data updated in the database.
     * @param {ObservationUpdateManyAndReturnArgs} args - Arguments to update many Observations.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Observations and only return the `id`
     * const observationWithIdOnly = await prisma.observation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ObservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Observation.
     * @param {ObservationUpsertArgs} args - Arguments to update or create a Observation.
     * @example
     * // Update or create a Observation
     * const observation = await prisma.observation.upsert({
     *   create: {
     *     // ... data to create a Observation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Observation we want to update
     *   }
     * })
     */
    upsert<T extends ObservationUpsertArgs>(args: SelectSubset<T, ObservationUpsertArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationCountArgs} args - Arguments to filter Observations to count.
     * @example
     * // Count the number of Observations
     * const count = await prisma.observation.count({
     *   where: {
     *     // ... the filter for the Observations we want to count
     *   }
     * })
    **/
    count<T extends ObservationCountArgs>(
      args?: Subset<T, ObservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationAggregateArgs>(args: Subset<T, ObservationAggregateArgs>): Prisma.PrismaPromise<GetObservationAggregateType<T>>

    /**
     * Group by Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationGroupByArgs['orderBy'] }
        : { orderBy?: ObservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Observation model
   */
  readonly fields: ObservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Observation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Observation model
   */
  interface ObservationFieldRefs {
    readonly id: FieldRef<"Observation", 'String'>
    readonly createdAt: FieldRef<"Observation", 'DateTime'>
    readonly patientId: FieldRef<"Observation", 'String'>
    readonly code: FieldRef<"Observation", 'String'>
    readonly value: FieldRef<"Observation", 'String'>
    readonly unit: FieldRef<"Observation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Observation findUnique
   */
  export type ObservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findUniqueOrThrow
   */
  export type ObservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findFirst
   */
  export type ObservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findFirstOrThrow
   */
  export type ObservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findMany
   */
  export type ObservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observations to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation create
   */
  export type ObservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Observation.
     */
    data: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
  }

  /**
   * Observation createMany
   */
  export type ObservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Observation createManyAndReturn
   */
  export type ObservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Observation update
   */
  export type ObservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Observation.
     */
    data: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
    /**
     * Choose, which Observation to update.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation updateMany
   */
  export type ObservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to update.
     */
    limit?: number
  }

  /**
   * Observation updateManyAndReturn
   */
  export type ObservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Observation upsert
   */
  export type ObservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Observation to update in case it exists.
     */
    where: ObservationWhereUniqueInput
    /**
     * In case the Observation found by the `where` argument doesn't exist, create a new Observation with this data.
     */
    create: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
    /**
     * In case the Observation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
  }

  /**
   * Observation delete
   */
  export type ObservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter which Observation to delete.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation deleteMany
   */
  export type ObservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observations to delete
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to delete.
     */
    limit?: number
  }

  /**
   * Observation without action
   */
  export type ObservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    medication: string | null
    dosage: string | null
    frequency: string | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    medication: string | null
    dosage: string | null
    frequency: string | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    medication: number
    dosage: number
    frequency: number
    _all: number
  }


  export type PrescriptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    medication?: true
    dosage?: true
    frequency?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    medication?: true
    dosage?: true
    frequency?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    medication?: true
    dosage?: true
    frequency?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    medication: string
    dosage: string
    frequency: string
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    medication?: boolean
    dosage?: boolean
    frequency?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    medication?: boolean
    dosage?: boolean
    frequency?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    medication?: boolean
    dosage?: boolean
    frequency?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    medication?: boolean
    dosage?: boolean
    frequency?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "medication" | "dosage" | "frequency", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      medication: string
      dosage: string
      frequency: string
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly medication: FieldRef<"Prescription", 'String'>
    readonly dosage: FieldRef<"Prescription", 'String'>
    readonly frequency: FieldRef<"Prescription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model DiagnosticReport
   */

  export type AggregateDiagnosticReport = {
    _count: DiagnosticReportCountAggregateOutputType | null
    _min: DiagnosticReportMinAggregateOutputType | null
    _max: DiagnosticReportMaxAggregateOutputType | null
  }

  export type DiagnosticReportMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    result: string | null
  }

  export type DiagnosticReportMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    result: string | null
  }

  export type DiagnosticReportCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    code: number
    result: number
    _all: number
  }


  export type DiagnosticReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    result?: true
  }

  export type DiagnosticReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    result?: true
  }

  export type DiagnosticReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    result?: true
    _all?: true
  }

  export type DiagnosticReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosticReport to aggregate.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiagnosticReports
    **/
    _count?: true | DiagnosticReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosticReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosticReportMaxAggregateInputType
  }

  export type GetDiagnosticReportAggregateType<T extends DiagnosticReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosticReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosticReport[P]>
      : GetScalarType<T[P], AggregateDiagnosticReport[P]>
  }




  export type DiagnosticReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosticReportWhereInput
    orderBy?: DiagnosticReportOrderByWithAggregationInput | DiagnosticReportOrderByWithAggregationInput[]
    by: DiagnosticReportScalarFieldEnum[] | DiagnosticReportScalarFieldEnum
    having?: DiagnosticReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosticReportCountAggregateInputType | true
    _min?: DiagnosticReportMinAggregateInputType
    _max?: DiagnosticReportMaxAggregateInputType
  }

  export type DiagnosticReportGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    code: string
    result: string
    _count: DiagnosticReportCountAggregateOutputType | null
    _min: DiagnosticReportMinAggregateOutputType | null
    _max: DiagnosticReportMaxAggregateOutputType | null
  }

  type GetDiagnosticReportGroupByPayload<T extends DiagnosticReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosticReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosticReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosticReportGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosticReportGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosticReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    result?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosticReport"]>

  export type DiagnosticReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    result?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosticReport"]>

  export type DiagnosticReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    result?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosticReport"]>

  export type DiagnosticReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    result?: boolean
  }

  export type DiagnosticReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "code" | "result", ExtArgs["result"]["diagnosticReport"]>
  export type DiagnosticReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DiagnosticReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DiagnosticReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DiagnosticReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiagnosticReport"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      code: string
      result: string
    }, ExtArgs["result"]["diagnosticReport"]>
    composites: {}
  }

  type DiagnosticReportGetPayload<S extends boolean | null | undefined | DiagnosticReportDefaultArgs> = $Result.GetResult<Prisma.$DiagnosticReportPayload, S>

  type DiagnosticReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiagnosticReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiagnosticReportCountAggregateInputType | true
    }

  export interface DiagnosticReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiagnosticReport'], meta: { name: 'DiagnosticReport' } }
    /**
     * Find zero or one DiagnosticReport that matches the filter.
     * @param {DiagnosticReportFindUniqueArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosticReportFindUniqueArgs>(args: SelectSubset<T, DiagnosticReportFindUniqueArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiagnosticReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiagnosticReportFindUniqueOrThrowArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosticReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosticReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiagnosticReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindFirstArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosticReportFindFirstArgs>(args?: SelectSubset<T, DiagnosticReportFindFirstArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiagnosticReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindFirstOrThrowArgs} args - Arguments to find a DiagnosticReport
     * @example
     * // Get one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosticReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosticReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiagnosticReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiagnosticReports
     * const diagnosticReports = await prisma.diagnosticReport.findMany()
     * 
     * // Get first 10 DiagnosticReports
     * const diagnosticReports = await prisma.diagnosticReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosticReportWithIdOnly = await prisma.diagnosticReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosticReportFindManyArgs>(args?: SelectSubset<T, DiagnosticReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiagnosticReport.
     * @param {DiagnosticReportCreateArgs} args - Arguments to create a DiagnosticReport.
     * @example
     * // Create one DiagnosticReport
     * const DiagnosticReport = await prisma.diagnosticReport.create({
     *   data: {
     *     // ... data to create a DiagnosticReport
     *   }
     * })
     * 
     */
    create<T extends DiagnosticReportCreateArgs>(args: SelectSubset<T, DiagnosticReportCreateArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiagnosticReports.
     * @param {DiagnosticReportCreateManyArgs} args - Arguments to create many DiagnosticReports.
     * @example
     * // Create many DiagnosticReports
     * const diagnosticReport = await prisma.diagnosticReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosticReportCreateManyArgs>(args?: SelectSubset<T, DiagnosticReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiagnosticReports and returns the data saved in the database.
     * @param {DiagnosticReportCreateManyAndReturnArgs} args - Arguments to create many DiagnosticReports.
     * @example
     * // Create many DiagnosticReports
     * const diagnosticReport = await prisma.diagnosticReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiagnosticReports and only return the `id`
     * const diagnosticReportWithIdOnly = await prisma.diagnosticReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosticReportCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosticReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiagnosticReport.
     * @param {DiagnosticReportDeleteArgs} args - Arguments to delete one DiagnosticReport.
     * @example
     * // Delete one DiagnosticReport
     * const DiagnosticReport = await prisma.diagnosticReport.delete({
     *   where: {
     *     // ... filter to delete one DiagnosticReport
     *   }
     * })
     * 
     */
    delete<T extends DiagnosticReportDeleteArgs>(args: SelectSubset<T, DiagnosticReportDeleteArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiagnosticReport.
     * @param {DiagnosticReportUpdateArgs} args - Arguments to update one DiagnosticReport.
     * @example
     * // Update one DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosticReportUpdateArgs>(args: SelectSubset<T, DiagnosticReportUpdateArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiagnosticReports.
     * @param {DiagnosticReportDeleteManyArgs} args - Arguments to filter DiagnosticReports to delete.
     * @example
     * // Delete a few DiagnosticReports
     * const { count } = await prisma.diagnosticReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosticReportDeleteManyArgs>(args?: SelectSubset<T, DiagnosticReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiagnosticReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiagnosticReports
     * const diagnosticReport = await prisma.diagnosticReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosticReportUpdateManyArgs>(args: SelectSubset<T, DiagnosticReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiagnosticReports and returns the data updated in the database.
     * @param {DiagnosticReportUpdateManyAndReturnArgs} args - Arguments to update many DiagnosticReports.
     * @example
     * // Update many DiagnosticReports
     * const diagnosticReport = await prisma.diagnosticReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiagnosticReports and only return the `id`
     * const diagnosticReportWithIdOnly = await prisma.diagnosticReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiagnosticReportUpdateManyAndReturnArgs>(args: SelectSubset<T, DiagnosticReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiagnosticReport.
     * @param {DiagnosticReportUpsertArgs} args - Arguments to update or create a DiagnosticReport.
     * @example
     * // Update or create a DiagnosticReport
     * const diagnosticReport = await prisma.diagnosticReport.upsert({
     *   create: {
     *     // ... data to create a DiagnosticReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiagnosticReport we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosticReportUpsertArgs>(args: SelectSubset<T, DiagnosticReportUpsertArgs<ExtArgs>>): Prisma__DiagnosticReportClient<$Result.GetResult<Prisma.$DiagnosticReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiagnosticReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportCountArgs} args - Arguments to filter DiagnosticReports to count.
     * @example
     * // Count the number of DiagnosticReports
     * const count = await prisma.diagnosticReport.count({
     *   where: {
     *     // ... the filter for the DiagnosticReports we want to count
     *   }
     * })
    **/
    count<T extends DiagnosticReportCountArgs>(
      args?: Subset<T, DiagnosticReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosticReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiagnosticReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosticReportAggregateArgs>(args: Subset<T, DiagnosticReportAggregateArgs>): Prisma.PrismaPromise<GetDiagnosticReportAggregateType<T>>

    /**
     * Group by DiagnosticReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosticReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosticReportGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosticReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosticReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosticReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiagnosticReport model
   */
  readonly fields: DiagnosticReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiagnosticReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosticReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiagnosticReport model
   */
  interface DiagnosticReportFieldRefs {
    readonly id: FieldRef<"DiagnosticReport", 'String'>
    readonly createdAt: FieldRef<"DiagnosticReport", 'DateTime'>
    readonly patientId: FieldRef<"DiagnosticReport", 'String'>
    readonly code: FieldRef<"DiagnosticReport", 'String'>
    readonly result: FieldRef<"DiagnosticReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DiagnosticReport findUnique
   */
  export type DiagnosticReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where: DiagnosticReportWhereUniqueInput
  }

  /**
   * DiagnosticReport findUniqueOrThrow
   */
  export type DiagnosticReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where: DiagnosticReportWhereUniqueInput
  }

  /**
   * DiagnosticReport findFirst
   */
  export type DiagnosticReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosticReports.
     */
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }

  /**
   * DiagnosticReport findFirstOrThrow
   */
  export type DiagnosticReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReport to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosticReports.
     */
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }

  /**
   * DiagnosticReport findMany
   */
  export type DiagnosticReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosticReports to fetch.
     */
    where?: DiagnosticReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosticReports to fetch.
     */
    orderBy?: DiagnosticReportOrderByWithRelationInput | DiagnosticReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiagnosticReports.
     */
    cursor?: DiagnosticReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosticReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosticReports.
     */
    skip?: number
    distinct?: DiagnosticReportScalarFieldEnum | DiagnosticReportScalarFieldEnum[]
  }

  /**
   * DiagnosticReport create
   */
  export type DiagnosticReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DiagnosticReport.
     */
    data: XOR<DiagnosticReportCreateInput, DiagnosticReportUncheckedCreateInput>
  }

  /**
   * DiagnosticReport createMany
   */
  export type DiagnosticReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiagnosticReports.
     */
    data: DiagnosticReportCreateManyInput | DiagnosticReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiagnosticReport createManyAndReturn
   */
  export type DiagnosticReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * The data used to create many DiagnosticReports.
     */
    data: DiagnosticReportCreateManyInput | DiagnosticReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiagnosticReport update
   */
  export type DiagnosticReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DiagnosticReport.
     */
    data: XOR<DiagnosticReportUpdateInput, DiagnosticReportUncheckedUpdateInput>
    /**
     * Choose, which DiagnosticReport to update.
     */
    where: DiagnosticReportWhereUniqueInput
  }

  /**
   * DiagnosticReport updateMany
   */
  export type DiagnosticReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiagnosticReports.
     */
    data: XOR<DiagnosticReportUpdateManyMutationInput, DiagnosticReportUncheckedUpdateManyInput>
    /**
     * Filter which DiagnosticReports to update
     */
    where?: DiagnosticReportWhereInput
    /**
     * Limit how many DiagnosticReports to update.
     */
    limit?: number
  }

  /**
   * DiagnosticReport updateManyAndReturn
   */
  export type DiagnosticReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * The data used to update DiagnosticReports.
     */
    data: XOR<DiagnosticReportUpdateManyMutationInput, DiagnosticReportUncheckedUpdateManyInput>
    /**
     * Filter which DiagnosticReports to update
     */
    where?: DiagnosticReportWhereInput
    /**
     * Limit how many DiagnosticReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiagnosticReport upsert
   */
  export type DiagnosticReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DiagnosticReport to update in case it exists.
     */
    where: DiagnosticReportWhereUniqueInput
    /**
     * In case the DiagnosticReport found by the `where` argument doesn't exist, create a new DiagnosticReport with this data.
     */
    create: XOR<DiagnosticReportCreateInput, DiagnosticReportUncheckedCreateInput>
    /**
     * In case the DiagnosticReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosticReportUpdateInput, DiagnosticReportUncheckedUpdateInput>
  }

  /**
   * DiagnosticReport delete
   */
  export type DiagnosticReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
    /**
     * Filter which DiagnosticReport to delete.
     */
    where: DiagnosticReportWhereUniqueInput
  }

  /**
   * DiagnosticReport deleteMany
   */
  export type DiagnosticReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosticReports to delete
     */
    where?: DiagnosticReportWhereInput
    /**
     * Limit how many DiagnosticReports to delete.
     */
    limit?: number
  }

  /**
   * DiagnosticReport without action
   */
  export type DiagnosticReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticReport
     */
    select?: DiagnosticReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiagnosticReport
     */
    omit?: DiagnosticReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosticReportInclude<ExtArgs> | null
  }


  /**
   * Model AllergyIntolerance
   */

  export type AggregateAllergyIntolerance = {
    _count: AllergyIntoleranceCountAggregateOutputType | null
    _min: AllergyIntoleranceMinAggregateOutputType | null
    _max: AllergyIntoleranceMaxAggregateOutputType | null
  }

  export type AllergyIntoleranceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    allergen: string | null
    reaction: string | null
    severity: string | null
  }

  export type AllergyIntoleranceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    allergen: string | null
    reaction: string | null
    severity: string | null
  }

  export type AllergyIntoleranceCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    allergen: number
    reaction: number
    severity: number
    _all: number
  }


  export type AllergyIntoleranceMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    allergen?: true
    reaction?: true
    severity?: true
  }

  export type AllergyIntoleranceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    allergen?: true
    reaction?: true
    severity?: true
  }

  export type AllergyIntoleranceCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    allergen?: true
    reaction?: true
    severity?: true
    _all?: true
  }

  export type AllergyIntoleranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllergyIntolerance to aggregate.
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllergyIntolerances to fetch.
     */
    orderBy?: AllergyIntoleranceOrderByWithRelationInput | AllergyIntoleranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergyIntoleranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllergyIntolerances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllergyIntolerances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AllergyIntolerances
    **/
    _count?: true | AllergyIntoleranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergyIntoleranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergyIntoleranceMaxAggregateInputType
  }

  export type GetAllergyIntoleranceAggregateType<T extends AllergyIntoleranceAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergyIntolerance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergyIntolerance[P]>
      : GetScalarType<T[P], AggregateAllergyIntolerance[P]>
  }




  export type AllergyIntoleranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergyIntoleranceWhereInput
    orderBy?: AllergyIntoleranceOrderByWithAggregationInput | AllergyIntoleranceOrderByWithAggregationInput[]
    by: AllergyIntoleranceScalarFieldEnum[] | AllergyIntoleranceScalarFieldEnum
    having?: AllergyIntoleranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergyIntoleranceCountAggregateInputType | true
    _min?: AllergyIntoleranceMinAggregateInputType
    _max?: AllergyIntoleranceMaxAggregateInputType
  }

  export type AllergyIntoleranceGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    allergen: string
    reaction: string | null
    severity: string | null
    _count: AllergyIntoleranceCountAggregateOutputType | null
    _min: AllergyIntoleranceMinAggregateOutputType | null
    _max: AllergyIntoleranceMaxAggregateOutputType | null
  }

  type GetAllergyIntoleranceGroupByPayload<T extends AllergyIntoleranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergyIntoleranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergyIntoleranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergyIntoleranceGroupByOutputType[P]>
            : GetScalarType<T[P], AllergyIntoleranceGroupByOutputType[P]>
        }
      >
    >


  export type AllergyIntoleranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    allergen?: boolean
    reaction?: boolean
    severity?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergyIntolerance"]>

  export type AllergyIntoleranceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    allergen?: boolean
    reaction?: boolean
    severity?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergyIntolerance"]>

  export type AllergyIntoleranceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    allergen?: boolean
    reaction?: boolean
    severity?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergyIntolerance"]>

  export type AllergyIntoleranceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    allergen?: boolean
    reaction?: boolean
    severity?: boolean
  }

  export type AllergyIntoleranceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "allergen" | "reaction" | "severity", ExtArgs["result"]["allergyIntolerance"]>
  export type AllergyIntoleranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergyIntoleranceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergyIntoleranceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AllergyIntolerancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AllergyIntolerance"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      allergen: string
      reaction: string | null
      severity: string | null
    }, ExtArgs["result"]["allergyIntolerance"]>
    composites: {}
  }

  type AllergyIntoleranceGetPayload<S extends boolean | null | undefined | AllergyIntoleranceDefaultArgs> = $Result.GetResult<Prisma.$AllergyIntolerancePayload, S>

  type AllergyIntoleranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllergyIntoleranceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllergyIntoleranceCountAggregateInputType | true
    }

  export interface AllergyIntoleranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AllergyIntolerance'], meta: { name: 'AllergyIntolerance' } }
    /**
     * Find zero or one AllergyIntolerance that matches the filter.
     * @param {AllergyIntoleranceFindUniqueArgs} args - Arguments to find a AllergyIntolerance
     * @example
     * // Get one AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllergyIntoleranceFindUniqueArgs>(args: SelectSubset<T, AllergyIntoleranceFindUniqueArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AllergyIntolerance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllergyIntoleranceFindUniqueOrThrowArgs} args - Arguments to find a AllergyIntolerance
     * @example
     * // Get one AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllergyIntoleranceFindUniqueOrThrowArgs>(args: SelectSubset<T, AllergyIntoleranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AllergyIntolerance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceFindFirstArgs} args - Arguments to find a AllergyIntolerance
     * @example
     * // Get one AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllergyIntoleranceFindFirstArgs>(args?: SelectSubset<T, AllergyIntoleranceFindFirstArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AllergyIntolerance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceFindFirstOrThrowArgs} args - Arguments to find a AllergyIntolerance
     * @example
     * // Get one AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllergyIntoleranceFindFirstOrThrowArgs>(args?: SelectSubset<T, AllergyIntoleranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AllergyIntolerances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AllergyIntolerances
     * const allergyIntolerances = await prisma.allergyIntolerance.findMany()
     * 
     * // Get first 10 AllergyIntolerances
     * const allergyIntolerances = await prisma.allergyIntolerance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergyIntoleranceWithIdOnly = await prisma.allergyIntolerance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllergyIntoleranceFindManyArgs>(args?: SelectSubset<T, AllergyIntoleranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AllergyIntolerance.
     * @param {AllergyIntoleranceCreateArgs} args - Arguments to create a AllergyIntolerance.
     * @example
     * // Create one AllergyIntolerance
     * const AllergyIntolerance = await prisma.allergyIntolerance.create({
     *   data: {
     *     // ... data to create a AllergyIntolerance
     *   }
     * })
     * 
     */
    create<T extends AllergyIntoleranceCreateArgs>(args: SelectSubset<T, AllergyIntoleranceCreateArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AllergyIntolerances.
     * @param {AllergyIntoleranceCreateManyArgs} args - Arguments to create many AllergyIntolerances.
     * @example
     * // Create many AllergyIntolerances
     * const allergyIntolerance = await prisma.allergyIntolerance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllergyIntoleranceCreateManyArgs>(args?: SelectSubset<T, AllergyIntoleranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AllergyIntolerances and returns the data saved in the database.
     * @param {AllergyIntoleranceCreateManyAndReturnArgs} args - Arguments to create many AllergyIntolerances.
     * @example
     * // Create many AllergyIntolerances
     * const allergyIntolerance = await prisma.allergyIntolerance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AllergyIntolerances and only return the `id`
     * const allergyIntoleranceWithIdOnly = await prisma.allergyIntolerance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllergyIntoleranceCreateManyAndReturnArgs>(args?: SelectSubset<T, AllergyIntoleranceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AllergyIntolerance.
     * @param {AllergyIntoleranceDeleteArgs} args - Arguments to delete one AllergyIntolerance.
     * @example
     * // Delete one AllergyIntolerance
     * const AllergyIntolerance = await prisma.allergyIntolerance.delete({
     *   where: {
     *     // ... filter to delete one AllergyIntolerance
     *   }
     * })
     * 
     */
    delete<T extends AllergyIntoleranceDeleteArgs>(args: SelectSubset<T, AllergyIntoleranceDeleteArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AllergyIntolerance.
     * @param {AllergyIntoleranceUpdateArgs} args - Arguments to update one AllergyIntolerance.
     * @example
     * // Update one AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllergyIntoleranceUpdateArgs>(args: SelectSubset<T, AllergyIntoleranceUpdateArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AllergyIntolerances.
     * @param {AllergyIntoleranceDeleteManyArgs} args - Arguments to filter AllergyIntolerances to delete.
     * @example
     * // Delete a few AllergyIntolerances
     * const { count } = await prisma.allergyIntolerance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllergyIntoleranceDeleteManyArgs>(args?: SelectSubset<T, AllergyIntoleranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllergyIntolerances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AllergyIntolerances
     * const allergyIntolerance = await prisma.allergyIntolerance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllergyIntoleranceUpdateManyArgs>(args: SelectSubset<T, AllergyIntoleranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllergyIntolerances and returns the data updated in the database.
     * @param {AllergyIntoleranceUpdateManyAndReturnArgs} args - Arguments to update many AllergyIntolerances.
     * @example
     * // Update many AllergyIntolerances
     * const allergyIntolerance = await prisma.allergyIntolerance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AllergyIntolerances and only return the `id`
     * const allergyIntoleranceWithIdOnly = await prisma.allergyIntolerance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllergyIntoleranceUpdateManyAndReturnArgs>(args: SelectSubset<T, AllergyIntoleranceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AllergyIntolerance.
     * @param {AllergyIntoleranceUpsertArgs} args - Arguments to update or create a AllergyIntolerance.
     * @example
     * // Update or create a AllergyIntolerance
     * const allergyIntolerance = await prisma.allergyIntolerance.upsert({
     *   create: {
     *     // ... data to create a AllergyIntolerance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AllergyIntolerance we want to update
     *   }
     * })
     */
    upsert<T extends AllergyIntoleranceUpsertArgs>(args: SelectSubset<T, AllergyIntoleranceUpsertArgs<ExtArgs>>): Prisma__AllergyIntoleranceClient<$Result.GetResult<Prisma.$AllergyIntolerancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AllergyIntolerances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceCountArgs} args - Arguments to filter AllergyIntolerances to count.
     * @example
     * // Count the number of AllergyIntolerances
     * const count = await prisma.allergyIntolerance.count({
     *   where: {
     *     // ... the filter for the AllergyIntolerances we want to count
     *   }
     * })
    **/
    count<T extends AllergyIntoleranceCountArgs>(
      args?: Subset<T, AllergyIntoleranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergyIntoleranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AllergyIntolerance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergyIntoleranceAggregateArgs>(args: Subset<T, AllergyIntoleranceAggregateArgs>): Prisma.PrismaPromise<GetAllergyIntoleranceAggregateType<T>>

    /**
     * Group by AllergyIntolerance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergyIntoleranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergyIntoleranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergyIntoleranceGroupByArgs['orderBy'] }
        : { orderBy?: AllergyIntoleranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergyIntoleranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergyIntoleranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AllergyIntolerance model
   */
  readonly fields: AllergyIntoleranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AllergyIntolerance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergyIntoleranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AllergyIntolerance model
   */
  interface AllergyIntoleranceFieldRefs {
    readonly id: FieldRef<"AllergyIntolerance", 'String'>
    readonly createdAt: FieldRef<"AllergyIntolerance", 'DateTime'>
    readonly patientId: FieldRef<"AllergyIntolerance", 'String'>
    readonly allergen: FieldRef<"AllergyIntolerance", 'String'>
    readonly reaction: FieldRef<"AllergyIntolerance", 'String'>
    readonly severity: FieldRef<"AllergyIntolerance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AllergyIntolerance findUnique
   */
  export type AllergyIntoleranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter, which AllergyIntolerance to fetch.
     */
    where: AllergyIntoleranceWhereUniqueInput
  }

  /**
   * AllergyIntolerance findUniqueOrThrow
   */
  export type AllergyIntoleranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter, which AllergyIntolerance to fetch.
     */
    where: AllergyIntoleranceWhereUniqueInput
  }

  /**
   * AllergyIntolerance findFirst
   */
  export type AllergyIntoleranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter, which AllergyIntolerance to fetch.
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllergyIntolerances to fetch.
     */
    orderBy?: AllergyIntoleranceOrderByWithRelationInput | AllergyIntoleranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllergyIntolerances.
     */
    cursor?: AllergyIntoleranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllergyIntolerances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllergyIntolerances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllergyIntolerances.
     */
    distinct?: AllergyIntoleranceScalarFieldEnum | AllergyIntoleranceScalarFieldEnum[]
  }

  /**
   * AllergyIntolerance findFirstOrThrow
   */
  export type AllergyIntoleranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter, which AllergyIntolerance to fetch.
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllergyIntolerances to fetch.
     */
    orderBy?: AllergyIntoleranceOrderByWithRelationInput | AllergyIntoleranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllergyIntolerances.
     */
    cursor?: AllergyIntoleranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllergyIntolerances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllergyIntolerances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllergyIntolerances.
     */
    distinct?: AllergyIntoleranceScalarFieldEnum | AllergyIntoleranceScalarFieldEnum[]
  }

  /**
   * AllergyIntolerance findMany
   */
  export type AllergyIntoleranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter, which AllergyIntolerances to fetch.
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllergyIntolerances to fetch.
     */
    orderBy?: AllergyIntoleranceOrderByWithRelationInput | AllergyIntoleranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AllergyIntolerances.
     */
    cursor?: AllergyIntoleranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllergyIntolerances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllergyIntolerances.
     */
    skip?: number
    distinct?: AllergyIntoleranceScalarFieldEnum | AllergyIntoleranceScalarFieldEnum[]
  }

  /**
   * AllergyIntolerance create
   */
  export type AllergyIntoleranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * The data needed to create a AllergyIntolerance.
     */
    data: XOR<AllergyIntoleranceCreateInput, AllergyIntoleranceUncheckedCreateInput>
  }

  /**
   * AllergyIntolerance createMany
   */
  export type AllergyIntoleranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AllergyIntolerances.
     */
    data: AllergyIntoleranceCreateManyInput | AllergyIntoleranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllergyIntolerance createManyAndReturn
   */
  export type AllergyIntoleranceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * The data used to create many AllergyIntolerances.
     */
    data: AllergyIntoleranceCreateManyInput | AllergyIntoleranceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AllergyIntolerance update
   */
  export type AllergyIntoleranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * The data needed to update a AllergyIntolerance.
     */
    data: XOR<AllergyIntoleranceUpdateInput, AllergyIntoleranceUncheckedUpdateInput>
    /**
     * Choose, which AllergyIntolerance to update.
     */
    where: AllergyIntoleranceWhereUniqueInput
  }

  /**
   * AllergyIntolerance updateMany
   */
  export type AllergyIntoleranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AllergyIntolerances.
     */
    data: XOR<AllergyIntoleranceUpdateManyMutationInput, AllergyIntoleranceUncheckedUpdateManyInput>
    /**
     * Filter which AllergyIntolerances to update
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * Limit how many AllergyIntolerances to update.
     */
    limit?: number
  }

  /**
   * AllergyIntolerance updateManyAndReturn
   */
  export type AllergyIntoleranceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * The data used to update AllergyIntolerances.
     */
    data: XOR<AllergyIntoleranceUpdateManyMutationInput, AllergyIntoleranceUncheckedUpdateManyInput>
    /**
     * Filter which AllergyIntolerances to update
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * Limit how many AllergyIntolerances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AllergyIntolerance upsert
   */
  export type AllergyIntoleranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * The filter to search for the AllergyIntolerance to update in case it exists.
     */
    where: AllergyIntoleranceWhereUniqueInput
    /**
     * In case the AllergyIntolerance found by the `where` argument doesn't exist, create a new AllergyIntolerance with this data.
     */
    create: XOR<AllergyIntoleranceCreateInput, AllergyIntoleranceUncheckedCreateInput>
    /**
     * In case the AllergyIntolerance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergyIntoleranceUpdateInput, AllergyIntoleranceUncheckedUpdateInput>
  }

  /**
   * AllergyIntolerance delete
   */
  export type AllergyIntoleranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
    /**
     * Filter which AllergyIntolerance to delete.
     */
    where: AllergyIntoleranceWhereUniqueInput
  }

  /**
   * AllergyIntolerance deleteMany
   */
  export type AllergyIntoleranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllergyIntolerances to delete
     */
    where?: AllergyIntoleranceWhereInput
    /**
     * Limit how many AllergyIntolerances to delete.
     */
    limit?: number
  }

  /**
   * AllergyIntolerance without action
   */
  export type AllergyIntoleranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergyIntolerance
     */
    select?: AllergyIntoleranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AllergyIntolerance
     */
    omit?: AllergyIntoleranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergyIntoleranceInclude<ExtArgs> | null
  }


  /**
   * Model DocumentReference
   */

  export type AggregateDocumentReference = {
    _count: DocumentReferenceCountAggregateOutputType | null
    _min: DocumentReferenceMinAggregateOutputType | null
    _max: DocumentReferenceMaxAggregateOutputType | null
  }

  export type DocumentReferenceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    title: string | null
    url: string | null
    type: string | null
  }

  export type DocumentReferenceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    title: string | null
    url: string | null
    type: string | null
  }

  export type DocumentReferenceCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    title: number
    url: number
    type: number
    _all: number
  }


  export type DocumentReferenceMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    title?: true
    url?: true
    type?: true
  }

  export type DocumentReferenceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    title?: true
    url?: true
    type?: true
  }

  export type DocumentReferenceCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    title?: true
    url?: true
    type?: true
    _all?: true
  }

  export type DocumentReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentReference to aggregate.
     */
    where?: DocumentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReferences to fetch.
     */
    orderBy?: DocumentReferenceOrderByWithRelationInput | DocumentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentReferences
    **/
    _count?: true | DocumentReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentReferenceMaxAggregateInputType
  }

  export type GetDocumentReferenceAggregateType<T extends DocumentReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentReference[P]>
      : GetScalarType<T[P], AggregateDocumentReference[P]>
  }




  export type DocumentReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReferenceWhereInput
    orderBy?: DocumentReferenceOrderByWithAggregationInput | DocumentReferenceOrderByWithAggregationInput[]
    by: DocumentReferenceScalarFieldEnum[] | DocumentReferenceScalarFieldEnum
    having?: DocumentReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentReferenceCountAggregateInputType | true
    _min?: DocumentReferenceMinAggregateInputType
    _max?: DocumentReferenceMaxAggregateInputType
  }

  export type DocumentReferenceGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    title: string
    url: string
    type: string
    _count: DocumentReferenceCountAggregateOutputType | null
    _min: DocumentReferenceMinAggregateOutputType | null
    _max: DocumentReferenceMaxAggregateOutputType | null
  }

  type GetDocumentReferenceGroupByPayload<T extends DocumentReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentReferenceGroupByOutputType[P]>
        }
      >
    >


  export type DocumentReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    title?: boolean
    url?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentReference"]>

  export type DocumentReferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    title?: boolean
    url?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentReference"]>

  export type DocumentReferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    title?: boolean
    url?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentReference"]>

  export type DocumentReferenceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    title?: boolean
    url?: boolean
    type?: boolean
  }

  export type DocumentReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "title" | "url" | "type", ExtArgs["result"]["documentReference"]>
  export type DocumentReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DocumentReferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DocumentReferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DocumentReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentReference"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      title: string
      url: string
      type: string
    }, ExtArgs["result"]["documentReference"]>
    composites: {}
  }

  type DocumentReferenceGetPayload<S extends boolean | null | undefined | DocumentReferenceDefaultArgs> = $Result.GetResult<Prisma.$DocumentReferencePayload, S>

  type DocumentReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentReferenceCountAggregateInputType | true
    }

  export interface DocumentReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentReference'], meta: { name: 'DocumentReference' } }
    /**
     * Find zero or one DocumentReference that matches the filter.
     * @param {DocumentReferenceFindUniqueArgs} args - Arguments to find a DocumentReference
     * @example
     * // Get one DocumentReference
     * const documentReference = await prisma.documentReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentReferenceFindUniqueArgs>(args: SelectSubset<T, DocumentReferenceFindUniqueArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentReferenceFindUniqueOrThrowArgs} args - Arguments to find a DocumentReference
     * @example
     * // Get one DocumentReference
     * const documentReference = await prisma.documentReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceFindFirstArgs} args - Arguments to find a DocumentReference
     * @example
     * // Get one DocumentReference
     * const documentReference = await prisma.documentReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentReferenceFindFirstArgs>(args?: SelectSubset<T, DocumentReferenceFindFirstArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceFindFirstOrThrowArgs} args - Arguments to find a DocumentReference
     * @example
     * // Get one DocumentReference
     * const documentReference = await prisma.documentReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentReferences
     * const documentReferences = await prisma.documentReference.findMany()
     * 
     * // Get first 10 DocumentReferences
     * const documentReferences = await prisma.documentReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentReferenceWithIdOnly = await prisma.documentReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentReferenceFindManyArgs>(args?: SelectSubset<T, DocumentReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentReference.
     * @param {DocumentReferenceCreateArgs} args - Arguments to create a DocumentReference.
     * @example
     * // Create one DocumentReference
     * const DocumentReference = await prisma.documentReference.create({
     *   data: {
     *     // ... data to create a DocumentReference
     *   }
     * })
     * 
     */
    create<T extends DocumentReferenceCreateArgs>(args: SelectSubset<T, DocumentReferenceCreateArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentReferences.
     * @param {DocumentReferenceCreateManyArgs} args - Arguments to create many DocumentReferences.
     * @example
     * // Create many DocumentReferences
     * const documentReference = await prisma.documentReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentReferenceCreateManyArgs>(args?: SelectSubset<T, DocumentReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentReferences and returns the data saved in the database.
     * @param {DocumentReferenceCreateManyAndReturnArgs} args - Arguments to create many DocumentReferences.
     * @example
     * // Create many DocumentReferences
     * const documentReference = await prisma.documentReference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentReferences and only return the `id`
     * const documentReferenceWithIdOnly = await prisma.documentReference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentReferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentReferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentReference.
     * @param {DocumentReferenceDeleteArgs} args - Arguments to delete one DocumentReference.
     * @example
     * // Delete one DocumentReference
     * const DocumentReference = await prisma.documentReference.delete({
     *   where: {
     *     // ... filter to delete one DocumentReference
     *   }
     * })
     * 
     */
    delete<T extends DocumentReferenceDeleteArgs>(args: SelectSubset<T, DocumentReferenceDeleteArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentReference.
     * @param {DocumentReferenceUpdateArgs} args - Arguments to update one DocumentReference.
     * @example
     * // Update one DocumentReference
     * const documentReference = await prisma.documentReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentReferenceUpdateArgs>(args: SelectSubset<T, DocumentReferenceUpdateArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentReferences.
     * @param {DocumentReferenceDeleteManyArgs} args - Arguments to filter DocumentReferences to delete.
     * @example
     * // Delete a few DocumentReferences
     * const { count } = await prisma.documentReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentReferenceDeleteManyArgs>(args?: SelectSubset<T, DocumentReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentReferences
     * const documentReference = await prisma.documentReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentReferenceUpdateManyArgs>(args: SelectSubset<T, DocumentReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentReferences and returns the data updated in the database.
     * @param {DocumentReferenceUpdateManyAndReturnArgs} args - Arguments to update many DocumentReferences.
     * @example
     * // Update many DocumentReferences
     * const documentReference = await prisma.documentReference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentReferences and only return the `id`
     * const documentReferenceWithIdOnly = await prisma.documentReference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentReferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentReferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentReference.
     * @param {DocumentReferenceUpsertArgs} args - Arguments to update or create a DocumentReference.
     * @example
     * // Update or create a DocumentReference
     * const documentReference = await prisma.documentReference.upsert({
     *   create: {
     *     // ... data to create a DocumentReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentReference we want to update
     *   }
     * })
     */
    upsert<T extends DocumentReferenceUpsertArgs>(args: SelectSubset<T, DocumentReferenceUpsertArgs<ExtArgs>>): Prisma__DocumentReferenceClient<$Result.GetResult<Prisma.$DocumentReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceCountArgs} args - Arguments to filter DocumentReferences to count.
     * @example
     * // Count the number of DocumentReferences
     * const count = await prisma.documentReference.count({
     *   where: {
     *     // ... the filter for the DocumentReferences we want to count
     *   }
     * })
    **/
    count<T extends DocumentReferenceCountArgs>(
      args?: Subset<T, DocumentReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentReferenceAggregateArgs>(args: Subset<T, DocumentReferenceAggregateArgs>): Prisma.PrismaPromise<GetDocumentReferenceAggregateType<T>>

    /**
     * Group by DocumentReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentReferenceGroupByArgs['orderBy'] }
        : { orderBy?: DocumentReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentReference model
   */
  readonly fields: DocumentReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentReference model
   */
  interface DocumentReferenceFieldRefs {
    readonly id: FieldRef<"DocumentReference", 'String'>
    readonly createdAt: FieldRef<"DocumentReference", 'DateTime'>
    readonly patientId: FieldRef<"DocumentReference", 'String'>
    readonly title: FieldRef<"DocumentReference", 'String'>
    readonly url: FieldRef<"DocumentReference", 'String'>
    readonly type: FieldRef<"DocumentReference", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentReference findUnique
   */
  export type DocumentReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReference to fetch.
     */
    where: DocumentReferenceWhereUniqueInput
  }

  /**
   * DocumentReference findUniqueOrThrow
   */
  export type DocumentReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReference to fetch.
     */
    where: DocumentReferenceWhereUniqueInput
  }

  /**
   * DocumentReference findFirst
   */
  export type DocumentReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReference to fetch.
     */
    where?: DocumentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReferences to fetch.
     */
    orderBy?: DocumentReferenceOrderByWithRelationInput | DocumentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentReferences.
     */
    cursor?: DocumentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentReferences.
     */
    distinct?: DocumentReferenceScalarFieldEnum | DocumentReferenceScalarFieldEnum[]
  }

  /**
   * DocumentReference findFirstOrThrow
   */
  export type DocumentReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReference to fetch.
     */
    where?: DocumentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReferences to fetch.
     */
    orderBy?: DocumentReferenceOrderByWithRelationInput | DocumentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentReferences.
     */
    cursor?: DocumentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentReferences.
     */
    distinct?: DocumentReferenceScalarFieldEnum | DocumentReferenceScalarFieldEnum[]
  }

  /**
   * DocumentReference findMany
   */
  export type DocumentReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReferences to fetch.
     */
    where?: DocumentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReferences to fetch.
     */
    orderBy?: DocumentReferenceOrderByWithRelationInput | DocumentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentReferences.
     */
    cursor?: DocumentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReferences.
     */
    skip?: number
    distinct?: DocumentReferenceScalarFieldEnum | DocumentReferenceScalarFieldEnum[]
  }

  /**
   * DocumentReference create
   */
  export type DocumentReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentReference.
     */
    data: XOR<DocumentReferenceCreateInput, DocumentReferenceUncheckedCreateInput>
  }

  /**
   * DocumentReference createMany
   */
  export type DocumentReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentReferences.
     */
    data: DocumentReferenceCreateManyInput | DocumentReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentReference createManyAndReturn
   */
  export type DocumentReferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentReferences.
     */
    data: DocumentReferenceCreateManyInput | DocumentReferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentReference update
   */
  export type DocumentReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentReference.
     */
    data: XOR<DocumentReferenceUpdateInput, DocumentReferenceUncheckedUpdateInput>
    /**
     * Choose, which DocumentReference to update.
     */
    where: DocumentReferenceWhereUniqueInput
  }

  /**
   * DocumentReference updateMany
   */
  export type DocumentReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentReferences.
     */
    data: XOR<DocumentReferenceUpdateManyMutationInput, DocumentReferenceUncheckedUpdateManyInput>
    /**
     * Filter which DocumentReferences to update
     */
    where?: DocumentReferenceWhereInput
    /**
     * Limit how many DocumentReferences to update.
     */
    limit?: number
  }

  /**
   * DocumentReference updateManyAndReturn
   */
  export type DocumentReferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * The data used to update DocumentReferences.
     */
    data: XOR<DocumentReferenceUpdateManyMutationInput, DocumentReferenceUncheckedUpdateManyInput>
    /**
     * Filter which DocumentReferences to update
     */
    where?: DocumentReferenceWhereInput
    /**
     * Limit how many DocumentReferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentReference upsert
   */
  export type DocumentReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentReference to update in case it exists.
     */
    where: DocumentReferenceWhereUniqueInput
    /**
     * In case the DocumentReference found by the `where` argument doesn't exist, create a new DocumentReference with this data.
     */
    create: XOR<DocumentReferenceCreateInput, DocumentReferenceUncheckedCreateInput>
    /**
     * In case the DocumentReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentReferenceUpdateInput, DocumentReferenceUncheckedUpdateInput>
  }

  /**
   * DocumentReference delete
   */
  export type DocumentReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
    /**
     * Filter which DocumentReference to delete.
     */
    where: DocumentReferenceWhereUniqueInput
  }

  /**
   * DocumentReference deleteMany
   */
  export type DocumentReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentReferences to delete
     */
    where?: DocumentReferenceWhereInput
    /**
     * Limit how many DocumentReferences to delete.
     */
    limit?: number
  }

  /**
   * DocumentReference without action
   */
  export type DocumentReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReference
     */
    select?: DocumentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentReference
     */
    omit?: DocumentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReferenceInclude<ExtArgs> | null
  }


  /**
   * Model Condition
   */

  export type AggregateCondition = {
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  export type ConditionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    name: string | null
    status: string | null
  }

  export type ConditionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    code: string | null
    name: string | null
    status: string | null
  }

  export type ConditionCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    code: number
    name: number
    status: number
    _all: number
  }


  export type ConditionMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    name?: true
    status?: true
  }

  export type ConditionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    name?: true
    status?: true
  }

  export type ConditionCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    code?: true
    name?: true
    status?: true
    _all?: true
  }

  export type ConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Condition to aggregate.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditions
    **/
    _count?: true | ConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionMaxAggregateInputType
  }

  export type GetConditionAggregateType<T extends ConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCondition[P]>
      : GetScalarType<T[P], AggregateCondition[P]>
  }




  export type ConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionWhereInput
    orderBy?: ConditionOrderByWithAggregationInput | ConditionOrderByWithAggregationInput[]
    by: ConditionScalarFieldEnum[] | ConditionScalarFieldEnum
    having?: ConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionCountAggregateInputType | true
    _min?: ConditionMinAggregateInputType
    _max?: ConditionMaxAggregateInputType
  }

  export type ConditionGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    code: string
    name: string
    status: string
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  type GetConditionGroupByPayload<T extends ConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionGroupByOutputType[P]>
        }
      >
    >


  export type ConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
  }

  export type ConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "code" | "name" | "status", ExtArgs["result"]["condition"]>
  export type ConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Condition"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      code: string
      name: string
      status: string
    }, ExtArgs["result"]["condition"]>
    composites: {}
  }

  type ConditionGetPayload<S extends boolean | null | undefined | ConditionDefaultArgs> = $Result.GetResult<Prisma.$ConditionPayload, S>

  type ConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConditionCountAggregateInputType | true
    }

  export interface ConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Condition'], meta: { name: 'Condition' } }
    /**
     * Find zero or one Condition that matches the filter.
     * @param {ConditionFindUniqueArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConditionFindUniqueArgs>(args: SelectSubset<T, ConditionFindUniqueArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Condition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConditionFindUniqueOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Condition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConditionFindFirstArgs>(args?: SelectSubset<T, ConditionFindFirstArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Condition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditions
     * const conditions = await prisma.condition.findMany()
     * 
     * // Get first 10 Conditions
     * const conditions = await prisma.condition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionWithIdOnly = await prisma.condition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConditionFindManyArgs>(args?: SelectSubset<T, ConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Condition.
     * @param {ConditionCreateArgs} args - Arguments to create a Condition.
     * @example
     * // Create one Condition
     * const Condition = await prisma.condition.create({
     *   data: {
     *     // ... data to create a Condition
     *   }
     * })
     * 
     */
    create<T extends ConditionCreateArgs>(args: SelectSubset<T, ConditionCreateArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conditions.
     * @param {ConditionCreateManyArgs} args - Arguments to create many Conditions.
     * @example
     * // Create many Conditions
     * const condition = await prisma.condition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConditionCreateManyArgs>(args?: SelectSubset<T, ConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conditions and returns the data saved in the database.
     * @param {ConditionCreateManyAndReturnArgs} args - Arguments to create many Conditions.
     * @example
     * // Create many Conditions
     * const condition = await prisma.condition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conditions and only return the `id`
     * const conditionWithIdOnly = await prisma.condition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Condition.
     * @param {ConditionDeleteArgs} args - Arguments to delete one Condition.
     * @example
     * // Delete one Condition
     * const Condition = await prisma.condition.delete({
     *   where: {
     *     // ... filter to delete one Condition
     *   }
     * })
     * 
     */
    delete<T extends ConditionDeleteArgs>(args: SelectSubset<T, ConditionDeleteArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Condition.
     * @param {ConditionUpdateArgs} args - Arguments to update one Condition.
     * @example
     * // Update one Condition
     * const condition = await prisma.condition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConditionUpdateArgs>(args: SelectSubset<T, ConditionUpdateArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conditions.
     * @param {ConditionDeleteManyArgs} args - Arguments to filter Conditions to delete.
     * @example
     * // Delete a few Conditions
     * const { count } = await prisma.condition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConditionDeleteManyArgs>(args?: SelectSubset<T, ConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditions
     * const condition = await prisma.condition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConditionUpdateManyArgs>(args: SelectSubset<T, ConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions and returns the data updated in the database.
     * @param {ConditionUpdateManyAndReturnArgs} args - Arguments to update many Conditions.
     * @example
     * // Update many Conditions
     * const condition = await prisma.condition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conditions and only return the `id`
     * const conditionWithIdOnly = await prisma.condition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Condition.
     * @param {ConditionUpsertArgs} args - Arguments to update or create a Condition.
     * @example
     * // Update or create a Condition
     * const condition = await prisma.condition.upsert({
     *   create: {
     *     // ... data to create a Condition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Condition we want to update
     *   }
     * })
     */
    upsert<T extends ConditionUpsertArgs>(args: SelectSubset<T, ConditionUpsertArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionCountArgs} args - Arguments to filter Conditions to count.
     * @example
     * // Count the number of Conditions
     * const count = await prisma.condition.count({
     *   where: {
     *     // ... the filter for the Conditions we want to count
     *   }
     * })
    **/
    count<T extends ConditionCountArgs>(
      args?: Subset<T, ConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionAggregateArgs>(args: Subset<T, ConditionAggregateArgs>): Prisma.PrismaPromise<GetConditionAggregateType<T>>

    /**
     * Group by Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionGroupByArgs['orderBy'] }
        : { orderBy?: ConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Condition model
   */
  readonly fields: ConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Condition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Condition model
   */
  interface ConditionFieldRefs {
    readonly id: FieldRef<"Condition", 'String'>
    readonly createdAt: FieldRef<"Condition", 'DateTime'>
    readonly patientId: FieldRef<"Condition", 'String'>
    readonly code: FieldRef<"Condition", 'String'>
    readonly name: FieldRef<"Condition", 'String'>
    readonly status: FieldRef<"Condition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Condition findUnique
   */
  export type ConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition findUniqueOrThrow
   */
  export type ConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition findFirst
   */
  export type ConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition findFirstOrThrow
   */
  export type ConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition findMany
   */
  export type ConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition create
   */
  export type ConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a Condition.
     */
    data: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
  }

  /**
   * Condition createMany
   */
  export type ConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conditions.
     */
    data: ConditionCreateManyInput | ConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Condition createManyAndReturn
   */
  export type ConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data used to create many Conditions.
     */
    data: ConditionCreateManyInput | ConditionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Condition update
   */
  export type ConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a Condition.
     */
    data: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
    /**
     * Choose, which Condition to update.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition updateMany
   */
  export type ConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to update.
     */
    limit?: number
  }

  /**
   * Condition updateManyAndReturn
   */
  export type ConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Condition upsert
   */
  export type ConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the Condition to update in case it exists.
     */
    where: ConditionWhereUniqueInput
    /**
     * In case the Condition found by the `where` argument doesn't exist, create a new Condition with this data.
     */
    create: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
    /**
     * In case the Condition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
  }

  /**
   * Condition delete
   */
  export type ConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter which Condition to delete.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition deleteMany
   */
  export type ConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditions to delete
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to delete.
     */
    limit?: number
  }

  /**
   * Condition without action
   */
  export type ConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionInclude<ExtArgs> | null
  }


  /**
   * Model Immunization
   */

  export type AggregateImmunization = {
    _count: ImmunizationCountAggregateOutputType | null
    _min: ImmunizationMinAggregateOutputType | null
    _max: ImmunizationMaxAggregateOutputType | null
  }

  export type ImmunizationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    vaccine: string | null
    date: Date | null
  }

  export type ImmunizationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    patientId: string | null
    vaccine: string | null
    date: Date | null
  }

  export type ImmunizationCountAggregateOutputType = {
    id: number
    createdAt: number
    patientId: number
    vaccine: number
    date: number
    _all: number
  }


  export type ImmunizationMinAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    vaccine?: true
    date?: true
  }

  export type ImmunizationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    vaccine?: true
    date?: true
  }

  export type ImmunizationCountAggregateInputType = {
    id?: true
    createdAt?: true
    patientId?: true
    vaccine?: true
    date?: true
    _all?: true
  }

  export type ImmunizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Immunization to aggregate.
     */
    where?: ImmunizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Immunizations to fetch.
     */
    orderBy?: ImmunizationOrderByWithRelationInput | ImmunizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImmunizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Immunizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Immunizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Immunizations
    **/
    _count?: true | ImmunizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImmunizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImmunizationMaxAggregateInputType
  }

  export type GetImmunizationAggregateType<T extends ImmunizationAggregateArgs> = {
        [P in keyof T & keyof AggregateImmunization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmunization[P]>
      : GetScalarType<T[P], AggregateImmunization[P]>
  }




  export type ImmunizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationWhereInput
    orderBy?: ImmunizationOrderByWithAggregationInput | ImmunizationOrderByWithAggregationInput[]
    by: ImmunizationScalarFieldEnum[] | ImmunizationScalarFieldEnum
    having?: ImmunizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImmunizationCountAggregateInputType | true
    _min?: ImmunizationMinAggregateInputType
    _max?: ImmunizationMaxAggregateInputType
  }

  export type ImmunizationGroupByOutputType = {
    id: string
    createdAt: Date
    patientId: string
    vaccine: string
    date: Date
    _count: ImmunizationCountAggregateOutputType | null
    _min: ImmunizationMinAggregateOutputType | null
    _max: ImmunizationMaxAggregateOutputType | null
  }

  type GetImmunizationGroupByPayload<T extends ImmunizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImmunizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImmunizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImmunizationGroupByOutputType[P]>
            : GetScalarType<T[P], ImmunizationGroupByOutputType[P]>
        }
      >
    >


  export type ImmunizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    vaccine?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immunization"]>

  export type ImmunizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    vaccine?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immunization"]>

  export type ImmunizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    vaccine?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immunization"]>

  export type ImmunizationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    patientId?: boolean
    vaccine?: boolean
    date?: boolean
  }

  export type ImmunizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "patientId" | "vaccine" | "date", ExtArgs["result"]["immunization"]>
  export type ImmunizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ImmunizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ImmunizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ImmunizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Immunization"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      patientId: string
      vaccine: string
      date: Date
    }, ExtArgs["result"]["immunization"]>
    composites: {}
  }

  type ImmunizationGetPayload<S extends boolean | null | undefined | ImmunizationDefaultArgs> = $Result.GetResult<Prisma.$ImmunizationPayload, S>

  type ImmunizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImmunizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImmunizationCountAggregateInputType | true
    }

  export interface ImmunizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Immunization'], meta: { name: 'Immunization' } }
    /**
     * Find zero or one Immunization that matches the filter.
     * @param {ImmunizationFindUniqueArgs} args - Arguments to find a Immunization
     * @example
     * // Get one Immunization
     * const immunization = await prisma.immunization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImmunizationFindUniqueArgs>(args: SelectSubset<T, ImmunizationFindUniqueArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Immunization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImmunizationFindUniqueOrThrowArgs} args - Arguments to find a Immunization
     * @example
     * // Get one Immunization
     * const immunization = await prisma.immunization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImmunizationFindUniqueOrThrowArgs>(args: SelectSubset<T, ImmunizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Immunization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationFindFirstArgs} args - Arguments to find a Immunization
     * @example
     * // Get one Immunization
     * const immunization = await prisma.immunization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImmunizationFindFirstArgs>(args?: SelectSubset<T, ImmunizationFindFirstArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Immunization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationFindFirstOrThrowArgs} args - Arguments to find a Immunization
     * @example
     * // Get one Immunization
     * const immunization = await prisma.immunization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImmunizationFindFirstOrThrowArgs>(args?: SelectSubset<T, ImmunizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Immunizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Immunizations
     * const immunizations = await prisma.immunization.findMany()
     * 
     * // Get first 10 Immunizations
     * const immunizations = await prisma.immunization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const immunizationWithIdOnly = await prisma.immunization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImmunizationFindManyArgs>(args?: SelectSubset<T, ImmunizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Immunization.
     * @param {ImmunizationCreateArgs} args - Arguments to create a Immunization.
     * @example
     * // Create one Immunization
     * const Immunization = await prisma.immunization.create({
     *   data: {
     *     // ... data to create a Immunization
     *   }
     * })
     * 
     */
    create<T extends ImmunizationCreateArgs>(args: SelectSubset<T, ImmunizationCreateArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Immunizations.
     * @param {ImmunizationCreateManyArgs} args - Arguments to create many Immunizations.
     * @example
     * // Create many Immunizations
     * const immunization = await prisma.immunization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImmunizationCreateManyArgs>(args?: SelectSubset<T, ImmunizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Immunizations and returns the data saved in the database.
     * @param {ImmunizationCreateManyAndReturnArgs} args - Arguments to create many Immunizations.
     * @example
     * // Create many Immunizations
     * const immunization = await prisma.immunization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Immunizations and only return the `id`
     * const immunizationWithIdOnly = await prisma.immunization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImmunizationCreateManyAndReturnArgs>(args?: SelectSubset<T, ImmunizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Immunization.
     * @param {ImmunizationDeleteArgs} args - Arguments to delete one Immunization.
     * @example
     * // Delete one Immunization
     * const Immunization = await prisma.immunization.delete({
     *   where: {
     *     // ... filter to delete one Immunization
     *   }
     * })
     * 
     */
    delete<T extends ImmunizationDeleteArgs>(args: SelectSubset<T, ImmunizationDeleteArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Immunization.
     * @param {ImmunizationUpdateArgs} args - Arguments to update one Immunization.
     * @example
     * // Update one Immunization
     * const immunization = await prisma.immunization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImmunizationUpdateArgs>(args: SelectSubset<T, ImmunizationUpdateArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Immunizations.
     * @param {ImmunizationDeleteManyArgs} args - Arguments to filter Immunizations to delete.
     * @example
     * // Delete a few Immunizations
     * const { count } = await prisma.immunization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImmunizationDeleteManyArgs>(args?: SelectSubset<T, ImmunizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Immunizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Immunizations
     * const immunization = await prisma.immunization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImmunizationUpdateManyArgs>(args: SelectSubset<T, ImmunizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Immunizations and returns the data updated in the database.
     * @param {ImmunizationUpdateManyAndReturnArgs} args - Arguments to update many Immunizations.
     * @example
     * // Update many Immunizations
     * const immunization = await prisma.immunization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Immunizations and only return the `id`
     * const immunizationWithIdOnly = await prisma.immunization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImmunizationUpdateManyAndReturnArgs>(args: SelectSubset<T, ImmunizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Immunization.
     * @param {ImmunizationUpsertArgs} args - Arguments to update or create a Immunization.
     * @example
     * // Update or create a Immunization
     * const immunization = await prisma.immunization.upsert({
     *   create: {
     *     // ... data to create a Immunization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Immunization we want to update
     *   }
     * })
     */
    upsert<T extends ImmunizationUpsertArgs>(args: SelectSubset<T, ImmunizationUpsertArgs<ExtArgs>>): Prisma__ImmunizationClient<$Result.GetResult<Prisma.$ImmunizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Immunizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationCountArgs} args - Arguments to filter Immunizations to count.
     * @example
     * // Count the number of Immunizations
     * const count = await prisma.immunization.count({
     *   where: {
     *     // ... the filter for the Immunizations we want to count
     *   }
     * })
    **/
    count<T extends ImmunizationCountArgs>(
      args?: Subset<T, ImmunizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImmunizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Immunization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImmunizationAggregateArgs>(args: Subset<T, ImmunizationAggregateArgs>): Prisma.PrismaPromise<GetImmunizationAggregateType<T>>

    /**
     * Group by Immunization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImmunizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImmunizationGroupByArgs['orderBy'] }
        : { orderBy?: ImmunizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImmunizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmunizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Immunization model
   */
  readonly fields: ImmunizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Immunization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImmunizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Immunization model
   */
  interface ImmunizationFieldRefs {
    readonly id: FieldRef<"Immunization", 'String'>
    readonly createdAt: FieldRef<"Immunization", 'DateTime'>
    readonly patientId: FieldRef<"Immunization", 'String'>
    readonly vaccine: FieldRef<"Immunization", 'String'>
    readonly date: FieldRef<"Immunization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Immunization findUnique
   */
  export type ImmunizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter, which Immunization to fetch.
     */
    where: ImmunizationWhereUniqueInput
  }

  /**
   * Immunization findUniqueOrThrow
   */
  export type ImmunizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter, which Immunization to fetch.
     */
    where: ImmunizationWhereUniqueInput
  }

  /**
   * Immunization findFirst
   */
  export type ImmunizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter, which Immunization to fetch.
     */
    where?: ImmunizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Immunizations to fetch.
     */
    orderBy?: ImmunizationOrderByWithRelationInput | ImmunizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Immunizations.
     */
    cursor?: ImmunizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Immunizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Immunizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Immunizations.
     */
    distinct?: ImmunizationScalarFieldEnum | ImmunizationScalarFieldEnum[]
  }

  /**
   * Immunization findFirstOrThrow
   */
  export type ImmunizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter, which Immunization to fetch.
     */
    where?: ImmunizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Immunizations to fetch.
     */
    orderBy?: ImmunizationOrderByWithRelationInput | ImmunizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Immunizations.
     */
    cursor?: ImmunizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Immunizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Immunizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Immunizations.
     */
    distinct?: ImmunizationScalarFieldEnum | ImmunizationScalarFieldEnum[]
  }

  /**
   * Immunization findMany
   */
  export type ImmunizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter, which Immunizations to fetch.
     */
    where?: ImmunizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Immunizations to fetch.
     */
    orderBy?: ImmunizationOrderByWithRelationInput | ImmunizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Immunizations.
     */
    cursor?: ImmunizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Immunizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Immunizations.
     */
    skip?: number
    distinct?: ImmunizationScalarFieldEnum | ImmunizationScalarFieldEnum[]
  }

  /**
   * Immunization create
   */
  export type ImmunizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Immunization.
     */
    data: XOR<ImmunizationCreateInput, ImmunizationUncheckedCreateInput>
  }

  /**
   * Immunization createMany
   */
  export type ImmunizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Immunizations.
     */
    data: ImmunizationCreateManyInput | ImmunizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Immunization createManyAndReturn
   */
  export type ImmunizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * The data used to create many Immunizations.
     */
    data: ImmunizationCreateManyInput | ImmunizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Immunization update
   */
  export type ImmunizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Immunization.
     */
    data: XOR<ImmunizationUpdateInput, ImmunizationUncheckedUpdateInput>
    /**
     * Choose, which Immunization to update.
     */
    where: ImmunizationWhereUniqueInput
  }

  /**
   * Immunization updateMany
   */
  export type ImmunizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Immunizations.
     */
    data: XOR<ImmunizationUpdateManyMutationInput, ImmunizationUncheckedUpdateManyInput>
    /**
     * Filter which Immunizations to update
     */
    where?: ImmunizationWhereInput
    /**
     * Limit how many Immunizations to update.
     */
    limit?: number
  }

  /**
   * Immunization updateManyAndReturn
   */
  export type ImmunizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * The data used to update Immunizations.
     */
    data: XOR<ImmunizationUpdateManyMutationInput, ImmunizationUncheckedUpdateManyInput>
    /**
     * Filter which Immunizations to update
     */
    where?: ImmunizationWhereInput
    /**
     * Limit how many Immunizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Immunization upsert
   */
  export type ImmunizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Immunization to update in case it exists.
     */
    where: ImmunizationWhereUniqueInput
    /**
     * In case the Immunization found by the `where` argument doesn't exist, create a new Immunization with this data.
     */
    create: XOR<ImmunizationCreateInput, ImmunizationUncheckedCreateInput>
    /**
     * In case the Immunization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImmunizationUpdateInput, ImmunizationUncheckedUpdateInput>
  }

  /**
   * Immunization delete
   */
  export type ImmunizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
    /**
     * Filter which Immunization to delete.
     */
    where: ImmunizationWhereUniqueInput
  }

  /**
   * Immunization deleteMany
   */
  export type ImmunizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Immunizations to delete
     */
    where?: ImmunizationWhereInput
    /**
     * Limit how many Immunizations to delete.
     */
    limit?: number
  }

  /**
   * Immunization without action
   */
  export type ImmunizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Immunization
     */
    select?: ImmunizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Immunization
     */
    omit?: ImmunizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    role: 'role',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    birthDate: 'birthDate',
    document: 'document',
    phone: 'phone',
    email: 'email',
    address: 'address',
    consentGivenAt: 'consentGivenAt',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cnpj: 'cnpj',
    contact: 'contact',
    email: 'email',
    phone: 'phone'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    unit: 'unit',
    sku: 'sku',
    minStock: 'minStock',
    isControlled: 'isControlled',
    createdAt: 'createdAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemBatchScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    batchCode: 'batchCode',
    expirationDate: 'expirationDate',
    unitCost: 'unitCost',
    quantityAvailable: 'quantityAvailable',
    createdAt: 'createdAt'
  };

  export type ItemBatchScalarFieldEnum = (typeof ItemBatchScalarFieldEnum)[keyof typeof ItemBatchScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    batchId: 'batchId',
    type: 'type',
    quantity: 'quantity',
    unitCost: 'unitCost',
    reason: 'reason',
    linkedProcedureId: 'linkedProcedureId',
    performedByUserId: 'performedByUserId',
    createdAt: 'createdAt'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const ProcedureTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    defaultDurationMin: 'defaultDurationMin',
    defaultItems: 'defaultItems'
  };

  export type ProcedureTypeScalarFieldEnum = (typeof ProcedureTypeScalarFieldEnum)[keyof typeof ProcedureTypeScalarFieldEnum]


  export const ProcedureScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    professionalUserId: 'professionalUserId',
    procedureTypeId: 'procedureTypeId',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    room: 'room',
    status: 'status',
    notes: 'notes'
  };

  export type ProcedureScalarFieldEnum = (typeof ProcedureScalarFieldEnum)[keyof typeof ProcedureScalarFieldEnum]


  export const CostSheetScalarFieldEnum: {
    id: 'id',
    procedureId: 'procedureId',
    itemsCost: 'itemsCost',
    laborCost: 'laborCost',
    overheadCost: 'overheadCost',
    totalCost: 'totalCost',
    marginTarget: 'marginTarget',
    suggestedPrice: 'suggestedPrice',
    createdAt: 'createdAt'
  };

  export type CostSheetScalarFieldEnum = (typeof CostSheetScalarFieldEnum)[keyof typeof CostSheetScalarFieldEnum]


  export const PriceRuleScalarFieldEnum: {
    id: 'id',
    scope: 'scope',
    scopeId: 'scopeId',
    marginTarget: 'marginTarget',
    minMargin: 'minMargin',
    maxMargin: 'maxMargin',
    dynamicAdjustments: 'dynamicAdjustments'
  };

  export type PriceRuleScalarFieldEnum = (typeof PriceRuleScalarFieldEnum)[keyof typeof PriceRuleScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    procedureId: 'procedureId',
    method: 'method',
    amount: 'amount',
    status: 'status',
    paidAt: 'paidAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userRole: 'userRole',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    tenantId: 'tenantId',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    description: 'description',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    accessPurpose: 'accessPurpose',
    justification: 'justification',
    previousHash: 'previousHash',
    currentHash: 'currentHash',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ClinicalNoteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    content: 'content',
    authorId: 'authorId',
    signed: 'signed',
    signedAt: 'signedAt'
  };

  export type ClinicalNoteScalarFieldEnum = (typeof ClinicalNoteScalarFieldEnum)[keyof typeof ClinicalNoteScalarFieldEnum]


  export const ObservationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    code: 'code',
    value: 'value',
    unit: 'unit'
  };

  export type ObservationScalarFieldEnum = (typeof ObservationScalarFieldEnum)[keyof typeof ObservationScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    medication: 'medication',
    dosage: 'dosage',
    frequency: 'frequency'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const DiagnosticReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    code: 'code',
    result: 'result'
  };

  export type DiagnosticReportScalarFieldEnum = (typeof DiagnosticReportScalarFieldEnum)[keyof typeof DiagnosticReportScalarFieldEnum]


  export const AllergyIntoleranceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    allergen: 'allergen',
    reaction: 'reaction',
    severity: 'severity'
  };

  export type AllergyIntoleranceScalarFieldEnum = (typeof AllergyIntoleranceScalarFieldEnum)[keyof typeof AllergyIntoleranceScalarFieldEnum]


  export const DocumentReferenceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    title: 'title',
    url: 'url',
    type: 'type'
  };

  export type DocumentReferenceScalarFieldEnum = (typeof DocumentReferenceScalarFieldEnum)[keyof typeof DocumentReferenceScalarFieldEnum]


  export const ConditionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    code: 'code',
    name: 'name',
    status: 'status'
  };

  export type ConditionScalarFieldEnum = (typeof ConditionScalarFieldEnum)[keyof typeof ConditionScalarFieldEnum]


  export const ImmunizationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    patientId: 'patientId',
    vaccine: 'vaccine',
    date: 'date'
  };

  export type ImmunizationScalarFieldEnum = (typeof ImmunizationScalarFieldEnum)[keyof typeof ImmunizationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'MovementType'
   */
  export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


  /**
   * Reference to a field of type 'MovementType[]'
   */
  export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ProcedureStatus'
   */
  export type EnumProcedureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcedureStatus'>
    


  /**
   * Reference to a field of type 'ProcedureStatus[]'
   */
  export type ListEnumProcedureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcedureStatus[]'>
    


  /**
   * Reference to a field of type 'PriceScope'
   */
  export type EnumPriceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceScope'>
    


  /**
   * Reference to a field of type 'PriceScope[]'
   */
  export type ListEnumPriceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceScope[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    procedures?: ProcedureListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procedures?: ProcedureOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    procedures?: ProcedureListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    document?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    consentGivenAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    procedures?: ProcedureListRelationFilter
    conditions?: ConditionListRelationFilter
    allergies?: AllergyIntoleranceListRelationFilter
    medications?: PrescriptionListRelationFilter
    immunizations?: ImmunizationListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    observations?: ObservationListRelationFilter
    diagnosticReports?: DiagnosticReportListRelationFilter
    documentReferences?: DocumentReferenceListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    consentGivenAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    procedures?: ProcedureOrderByRelationAggregateInput
    conditions?: ConditionOrderByRelationAggregateInput
    allergies?: AllergyIntoleranceOrderByRelationAggregateInput
    medications?: PrescriptionOrderByRelationAggregateInput
    immunizations?: ImmunizationOrderByRelationAggregateInput
    clinicalNotes?: ClinicalNoteOrderByRelationAggregateInput
    observations?: ObservationOrderByRelationAggregateInput
    diagnosticReports?: DiagnosticReportOrderByRelationAggregateInput
    documentReferences?: DocumentReferenceOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    document?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    name?: StringFilter<"Patient"> | string
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    consentGivenAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    procedures?: ProcedureListRelationFilter
    conditions?: ConditionListRelationFilter
    allergies?: AllergyIntoleranceListRelationFilter
    medications?: PrescriptionListRelationFilter
    immunizations?: ImmunizationListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    observations?: ObservationListRelationFilter
    diagnosticReports?: DiagnosticReportListRelationFilter
    documentReferences?: DocumentReferenceListRelationFilter
  }, "id" | "document">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    consentGivenAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    document?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    consentGivenAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    cnpj?: StringNullableFilter<"Supplier"> | string | null
    contact?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
  }, "id" | "cnpj">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    cnpj?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    category?: StringNullableFilter<"Item"> | string | null
    unit?: StringFilter<"Item"> | string
    sku?: StringNullableFilter<"Item"> | string | null
    minStock?: FloatFilter<"Item"> | number
    isControlled?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    batches?: ItemBatchListRelationFilter
    movements?: InventoryMovementListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    sku?: SortOrderInput | SortOrder
    minStock?: SortOrder
    isControlled?: SortOrder
    createdAt?: SortOrder
    batches?: ItemBatchOrderByRelationAggregateInput
    movements?: InventoryMovementOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    category?: StringNullableFilter<"Item"> | string | null
    unit?: StringFilter<"Item"> | string
    minStock?: FloatFilter<"Item"> | number
    isControlled?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    batches?: ItemBatchListRelationFilter
    movements?: InventoryMovementListRelationFilter
  }, "id" | "sku">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrder
    sku?: SortOrderInput | SortOrder
    minStock?: SortOrder
    isControlled?: SortOrder
    createdAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    category?: StringNullableWithAggregatesFilter<"Item"> | string | null
    unit?: StringWithAggregatesFilter<"Item"> | string
    sku?: StringNullableWithAggregatesFilter<"Item"> | string | null
    minStock?: FloatWithAggregatesFilter<"Item"> | number
    isControlled?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type ItemBatchWhereInput = {
    AND?: ItemBatchWhereInput | ItemBatchWhereInput[]
    OR?: ItemBatchWhereInput[]
    NOT?: ItemBatchWhereInput | ItemBatchWhereInput[]
    id?: StringFilter<"ItemBatch"> | string
    itemId?: StringFilter<"ItemBatch"> | string
    batchCode?: StringFilter<"ItemBatch"> | string
    expirationDate?: DateTimeNullableFilter<"ItemBatch"> | Date | string | null
    unitCost?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ItemBatch"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    movements?: InventoryMovementListRelationFilter
  }

  export type ItemBatchOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchCode?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
    createdAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    movements?: InventoryMovementOrderByRelationAggregateInput
  }

  export type ItemBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemBatchWhereInput | ItemBatchWhereInput[]
    OR?: ItemBatchWhereInput[]
    NOT?: ItemBatchWhereInput | ItemBatchWhereInput[]
    itemId?: StringFilter<"ItemBatch"> | string
    batchCode?: StringFilter<"ItemBatch"> | string
    expirationDate?: DateTimeNullableFilter<"ItemBatch"> | Date | string | null
    unitCost?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ItemBatch"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    movements?: InventoryMovementListRelationFilter
  }, "id">

  export type ItemBatchOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchCode?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
    createdAt?: SortOrder
    _count?: ItemBatchCountOrderByAggregateInput
    _avg?: ItemBatchAvgOrderByAggregateInput
    _max?: ItemBatchMaxOrderByAggregateInput
    _min?: ItemBatchMinOrderByAggregateInput
    _sum?: ItemBatchSumOrderByAggregateInput
  }

  export type ItemBatchScalarWhereWithAggregatesInput = {
    AND?: ItemBatchScalarWhereWithAggregatesInput | ItemBatchScalarWhereWithAggregatesInput[]
    OR?: ItemBatchScalarWhereWithAggregatesInput[]
    NOT?: ItemBatchScalarWhereWithAggregatesInput | ItemBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemBatch"> | string
    itemId?: StringWithAggregatesFilter<"ItemBatch"> | string
    batchCode?: StringWithAggregatesFilter<"ItemBatch"> | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"ItemBatch"> | Date | string | null
    unitCost?: DecimalWithAggregatesFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalWithAggregatesFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ItemBatch"> | Date | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    itemId?: StringFilter<"InventoryMovement"> | string
    batchId?: StringNullableFilter<"InventoryMovement"> | string | null
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: DecimalFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    linkedProcedureId?: StringNullableFilter<"InventoryMovement"> | string | null
    performedByUserId?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    batch?: XOR<ItemBatchNullableScalarRelationFilter, ItemBatchWhereInput> | null
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    linkedProcedureId?: SortOrderInput | SortOrder
    performedByUserId?: SortOrder
    createdAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    batch?: ItemBatchOrderByWithRelationInput
    performedBy?: UserOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    itemId?: StringFilter<"InventoryMovement"> | string
    batchId?: StringNullableFilter<"InventoryMovement"> | string | null
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: DecimalFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    linkedProcedureId?: StringNullableFilter<"InventoryMovement"> | string | null
    performedByUserId?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    batch?: XOR<ItemBatchNullableScalarRelationFilter, ItemBatchWhereInput> | null
    performedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    linkedProcedureId?: SortOrderInput | SortOrder
    performedByUserId?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    itemId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    batchId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    type?: EnumMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: DecimalWithAggregatesFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableWithAggregatesFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    linkedProcedureId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    performedByUserId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type ProcedureTypeWhereInput = {
    AND?: ProcedureTypeWhereInput | ProcedureTypeWhereInput[]
    OR?: ProcedureTypeWhereInput[]
    NOT?: ProcedureTypeWhereInput | ProcedureTypeWhereInput[]
    id?: StringFilter<"ProcedureType"> | string
    name?: StringFilter<"ProcedureType"> | string
    description?: StringNullableFilter<"ProcedureType"> | string | null
    defaultDurationMin?: IntFilter<"ProcedureType"> | number
    defaultItems?: JsonFilter<"ProcedureType">
    procedures?: ProcedureListRelationFilter
  }

  export type ProcedureTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDurationMin?: SortOrder
    defaultItems?: SortOrder
    procedures?: ProcedureOrderByRelationAggregateInput
  }

  export type ProcedureTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcedureTypeWhereInput | ProcedureTypeWhereInput[]
    OR?: ProcedureTypeWhereInput[]
    NOT?: ProcedureTypeWhereInput | ProcedureTypeWhereInput[]
    name?: StringFilter<"ProcedureType"> | string
    description?: StringNullableFilter<"ProcedureType"> | string | null
    defaultDurationMin?: IntFilter<"ProcedureType"> | number
    defaultItems?: JsonFilter<"ProcedureType">
    procedures?: ProcedureListRelationFilter
  }, "id">

  export type ProcedureTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDurationMin?: SortOrder
    defaultItems?: SortOrder
    _count?: ProcedureTypeCountOrderByAggregateInput
    _avg?: ProcedureTypeAvgOrderByAggregateInput
    _max?: ProcedureTypeMaxOrderByAggregateInput
    _min?: ProcedureTypeMinOrderByAggregateInput
    _sum?: ProcedureTypeSumOrderByAggregateInput
  }

  export type ProcedureTypeScalarWhereWithAggregatesInput = {
    AND?: ProcedureTypeScalarWhereWithAggregatesInput | ProcedureTypeScalarWhereWithAggregatesInput[]
    OR?: ProcedureTypeScalarWhereWithAggregatesInput[]
    NOT?: ProcedureTypeScalarWhereWithAggregatesInput | ProcedureTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcedureType"> | string
    name?: StringWithAggregatesFilter<"ProcedureType"> | string
    description?: StringNullableWithAggregatesFilter<"ProcedureType"> | string | null
    defaultDurationMin?: IntWithAggregatesFilter<"ProcedureType"> | number
    defaultItems?: JsonWithAggregatesFilter<"ProcedureType">
  }

  export type ProcedureWhereInput = {
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    id?: StringFilter<"Procedure"> | string
    patientId?: StringFilter<"Procedure"> | string
    professionalUserId?: StringFilter<"Procedure"> | string
    procedureTypeId?: StringFilter<"Procedure"> | string
    scheduledAt?: DateTimeFilter<"Procedure"> | Date | string
    startedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    room?: StringNullableFilter<"Procedure"> | string | null
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    notes?: StringNullableFilter<"Procedure"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    professional?: XOR<UserScalarRelationFilter, UserWhereInput>
    procedureType?: XOR<ProcedureTypeScalarRelationFilter, ProcedureTypeWhereInput>
    costSheet?: XOR<CostSheetNullableScalarRelationFilter, CostSheetWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type ProcedureOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    professionalUserId?: SortOrder
    procedureTypeId?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    professional?: UserOrderByWithRelationInput
    procedureType?: ProcedureTypeOrderByWithRelationInput
    costSheet?: CostSheetOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type ProcedureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    patientId?: StringFilter<"Procedure"> | string
    professionalUserId?: StringFilter<"Procedure"> | string
    procedureTypeId?: StringFilter<"Procedure"> | string
    scheduledAt?: DateTimeFilter<"Procedure"> | Date | string
    startedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    room?: StringNullableFilter<"Procedure"> | string | null
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    notes?: StringNullableFilter<"Procedure"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    professional?: XOR<UserScalarRelationFilter, UserWhereInput>
    procedureType?: XOR<ProcedureTypeScalarRelationFilter, ProcedureTypeWhereInput>
    costSheet?: XOR<CostSheetNullableScalarRelationFilter, CostSheetWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type ProcedureOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    professionalUserId?: SortOrder
    procedureTypeId?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ProcedureCountOrderByAggregateInput
    _max?: ProcedureMaxOrderByAggregateInput
    _min?: ProcedureMinOrderByAggregateInput
  }

  export type ProcedureScalarWhereWithAggregatesInput = {
    AND?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    OR?: ProcedureScalarWhereWithAggregatesInput[]
    NOT?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Procedure"> | string
    patientId?: StringWithAggregatesFilter<"Procedure"> | string
    professionalUserId?: StringWithAggregatesFilter<"Procedure"> | string
    procedureTypeId?: StringWithAggregatesFilter<"Procedure"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Procedure"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Procedure"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"Procedure"> | Date | string | null
    room?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
    status?: EnumProcedureStatusWithAggregatesFilter<"Procedure"> | $Enums.ProcedureStatus
    notes?: StringNullableWithAggregatesFilter<"Procedure"> | string | null
  }

  export type CostSheetWhereInput = {
    AND?: CostSheetWhereInput | CostSheetWhereInput[]
    OR?: CostSheetWhereInput[]
    NOT?: CostSheetWhereInput | CostSheetWhereInput[]
    id?: StringFilter<"CostSheet"> | string
    procedureId?: StringFilter<"CostSheet"> | string
    itemsCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CostSheet"> | Date | string
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }

  export type CostSheetOrderByWithRelationInput = {
    id?: SortOrder
    procedureId?: SortOrder
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
    createdAt?: SortOrder
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type CostSheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    procedureId?: string
    AND?: CostSheetWhereInput | CostSheetWhereInput[]
    OR?: CostSheetWhereInput[]
    NOT?: CostSheetWhereInput | CostSheetWhereInput[]
    itemsCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CostSheet"> | Date | string
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }, "id" | "procedureId">

  export type CostSheetOrderByWithAggregationInput = {
    id?: SortOrder
    procedureId?: SortOrder
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
    createdAt?: SortOrder
    _count?: CostSheetCountOrderByAggregateInput
    _avg?: CostSheetAvgOrderByAggregateInput
    _max?: CostSheetMaxOrderByAggregateInput
    _min?: CostSheetMinOrderByAggregateInput
    _sum?: CostSheetSumOrderByAggregateInput
  }

  export type CostSheetScalarWhereWithAggregatesInput = {
    AND?: CostSheetScalarWhereWithAggregatesInput | CostSheetScalarWhereWithAggregatesInput[]
    OR?: CostSheetScalarWhereWithAggregatesInput[]
    NOT?: CostSheetScalarWhereWithAggregatesInput | CostSheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostSheet"> | string
    procedureId?: StringWithAggregatesFilter<"CostSheet"> | string
    itemsCost?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalWithAggregatesFilter<"CostSheet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CostSheet"> | Date | string
  }

  export type PriceRuleWhereInput = {
    AND?: PriceRuleWhereInput | PriceRuleWhereInput[]
    OR?: PriceRuleWhereInput[]
    NOT?: PriceRuleWhereInput | PriceRuleWhereInput[]
    id?: StringFilter<"PriceRule"> | string
    scope?: EnumPriceScopeFilter<"PriceRule"> | $Enums.PriceScope
    scopeId?: StringNullableFilter<"PriceRule"> | string | null
    marginTarget?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: JsonNullableFilter<"PriceRule">
  }

  export type PriceRuleOrderByWithRelationInput = {
    id?: SortOrder
    scope?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
    dynamicAdjustments?: SortOrderInput | SortOrder
  }

  export type PriceRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceRuleWhereInput | PriceRuleWhereInput[]
    OR?: PriceRuleWhereInput[]
    NOT?: PriceRuleWhereInput | PriceRuleWhereInput[]
    scope?: EnumPriceScopeFilter<"PriceRule"> | $Enums.PriceScope
    scopeId?: StringNullableFilter<"PriceRule"> | string | null
    marginTarget?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: JsonNullableFilter<"PriceRule">
  }, "id">

  export type PriceRuleOrderByWithAggregationInput = {
    id?: SortOrder
    scope?: SortOrder
    scopeId?: SortOrderInput | SortOrder
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
    dynamicAdjustments?: SortOrderInput | SortOrder
    _count?: PriceRuleCountOrderByAggregateInput
    _avg?: PriceRuleAvgOrderByAggregateInput
    _max?: PriceRuleMaxOrderByAggregateInput
    _min?: PriceRuleMinOrderByAggregateInput
    _sum?: PriceRuleSumOrderByAggregateInput
  }

  export type PriceRuleScalarWhereWithAggregatesInput = {
    AND?: PriceRuleScalarWhereWithAggregatesInput | PriceRuleScalarWhereWithAggregatesInput[]
    OR?: PriceRuleScalarWhereWithAggregatesInput[]
    NOT?: PriceRuleScalarWhereWithAggregatesInput | PriceRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceRule"> | string
    scope?: EnumPriceScopeWithAggregatesFilter<"PriceRule"> | $Enums.PriceScope
    scopeId?: StringNullableWithAggregatesFilter<"PriceRule"> | string | null
    marginTarget?: DecimalWithAggregatesFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalWithAggregatesFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalWithAggregatesFilter<"PriceRule"> | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: JsonNullableWithAggregatesFilter<"PriceRule">
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    procedureId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    procedureId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    procedureId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    procedure?: XOR<ProcedureScalarRelationFilter, ProcedureWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    procedureId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    procedureId?: StringWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    userRole?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    resourceType?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    accessPurpose?: StringNullableFilter<"AuditLog"> | string | null
    justification?: StringNullableFilter<"AuditLog"> | string | null
    previousHash?: StringNullableFilter<"AuditLog"> | string | null
    currentHash?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    accessPurpose?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    previousHash?: SortOrderInput | SortOrder
    currentHash?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    userRole?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    resourceType?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    accessPurpose?: StringNullableFilter<"AuditLog"> | string | null
    justification?: StringNullableFilter<"AuditLog"> | string | null
    previousHash?: StringNullableFilter<"AuditLog"> | string | null
    currentHash?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    resourceType?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    accessPurpose?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    previousHash?: SortOrderInput | SortOrder
    currentHash?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userRole?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    accessPurpose?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    justification?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    previousHash?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    currentHash?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ClinicalNoteWhereInput = {
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    patientId?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    signed?: BoolFilter<"ClinicalNote"> | boolean
    signedAt?: DateTimeNullableFilter<"ClinicalNote"> | Date | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type ClinicalNoteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ClinicalNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    patientId?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    signed?: BoolFilter<"ClinicalNote"> | boolean
    signedAt?: DateTimeNullableFilter<"ClinicalNote"> | Date | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type ClinicalNoteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    _count?: ClinicalNoteCountOrderByAggregateInput
    _max?: ClinicalNoteMaxOrderByAggregateInput
    _min?: ClinicalNoteMinOrderByAggregateInput
  }

  export type ClinicalNoteScalarWhereWithAggregatesInput = {
    AND?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    OR?: ClinicalNoteScalarWhereWithAggregatesInput[]
    NOT?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClinicalNote"> | Date | string
    patientId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    content?: StringWithAggregatesFilter<"ClinicalNote"> | string
    authorId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    signed?: BoolWithAggregatesFilter<"ClinicalNote"> | boolean
    signedAt?: DateTimeNullableWithAggregatesFilter<"ClinicalNote"> | Date | string | null
  }

  export type ObservationWhereInput = {
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    id?: StringFilter<"Observation"> | string
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    patientId?: StringFilter<"Observation"> | string
    code?: StringFilter<"Observation"> | string
    value?: StringFilter<"Observation"> | string
    unit?: StringNullableFilter<"Observation"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type ObservationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ObservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    patientId?: StringFilter<"Observation"> | string
    code?: StringFilter<"Observation"> | string
    value?: StringFilter<"Observation"> | string
    unit?: StringNullableFilter<"Observation"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type ObservationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: ObservationCountOrderByAggregateInput
    _max?: ObservationMaxOrderByAggregateInput
    _min?: ObservationMinOrderByAggregateInput
  }

  export type ObservationScalarWhereWithAggregatesInput = {
    AND?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    OR?: ObservationScalarWhereWithAggregatesInput[]
    NOT?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Observation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    patientId?: StringWithAggregatesFilter<"Observation"> | string
    code?: StringWithAggregatesFilter<"Observation"> | string
    value?: StringWithAggregatesFilter<"Observation"> | string
    unit?: StringNullableWithAggregatesFilter<"Observation"> | string | null
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    patientId?: StringFilter<"Prescription"> | string
    medication?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    medication?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    patientId?: StringFilter<"Prescription"> | string
    medication?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    medication?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    patientId?: StringWithAggregatesFilter<"Prescription"> | string
    medication?: StringWithAggregatesFilter<"Prescription"> | string
    dosage?: StringWithAggregatesFilter<"Prescription"> | string
    frequency?: StringWithAggregatesFilter<"Prescription"> | string
  }

  export type DiagnosticReportWhereInput = {
    AND?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    OR?: DiagnosticReportWhereInput[]
    NOT?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    id?: StringFilter<"DiagnosticReport"> | string
    createdAt?: DateTimeFilter<"DiagnosticReport"> | Date | string
    patientId?: StringFilter<"DiagnosticReport"> | string
    code?: StringFilter<"DiagnosticReport"> | string
    result?: StringFilter<"DiagnosticReport"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type DiagnosticReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    result?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type DiagnosticReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    OR?: DiagnosticReportWhereInput[]
    NOT?: DiagnosticReportWhereInput | DiagnosticReportWhereInput[]
    createdAt?: DateTimeFilter<"DiagnosticReport"> | Date | string
    patientId?: StringFilter<"DiagnosticReport"> | string
    code?: StringFilter<"DiagnosticReport"> | string
    result?: StringFilter<"DiagnosticReport"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type DiagnosticReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    result?: SortOrder
    _count?: DiagnosticReportCountOrderByAggregateInput
    _max?: DiagnosticReportMaxOrderByAggregateInput
    _min?: DiagnosticReportMinOrderByAggregateInput
  }

  export type DiagnosticReportScalarWhereWithAggregatesInput = {
    AND?: DiagnosticReportScalarWhereWithAggregatesInput | DiagnosticReportScalarWhereWithAggregatesInput[]
    OR?: DiagnosticReportScalarWhereWithAggregatesInput[]
    NOT?: DiagnosticReportScalarWhereWithAggregatesInput | DiagnosticReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiagnosticReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DiagnosticReport"> | Date | string
    patientId?: StringWithAggregatesFilter<"DiagnosticReport"> | string
    code?: StringWithAggregatesFilter<"DiagnosticReport"> | string
    result?: StringWithAggregatesFilter<"DiagnosticReport"> | string
  }

  export type AllergyIntoleranceWhereInput = {
    AND?: AllergyIntoleranceWhereInput | AllergyIntoleranceWhereInput[]
    OR?: AllergyIntoleranceWhereInput[]
    NOT?: AllergyIntoleranceWhereInput | AllergyIntoleranceWhereInput[]
    id?: StringFilter<"AllergyIntolerance"> | string
    createdAt?: DateTimeFilter<"AllergyIntolerance"> | Date | string
    patientId?: StringFilter<"AllergyIntolerance"> | string
    allergen?: StringFilter<"AllergyIntolerance"> | string
    reaction?: StringNullableFilter<"AllergyIntolerance"> | string | null
    severity?: StringNullableFilter<"AllergyIntolerance"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AllergyIntoleranceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    allergen?: SortOrder
    reaction?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AllergyIntoleranceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllergyIntoleranceWhereInput | AllergyIntoleranceWhereInput[]
    OR?: AllergyIntoleranceWhereInput[]
    NOT?: AllergyIntoleranceWhereInput | AllergyIntoleranceWhereInput[]
    createdAt?: DateTimeFilter<"AllergyIntolerance"> | Date | string
    patientId?: StringFilter<"AllergyIntolerance"> | string
    allergen?: StringFilter<"AllergyIntolerance"> | string
    reaction?: StringNullableFilter<"AllergyIntolerance"> | string | null
    severity?: StringNullableFilter<"AllergyIntolerance"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AllergyIntoleranceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    allergen?: SortOrder
    reaction?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    _count?: AllergyIntoleranceCountOrderByAggregateInput
    _max?: AllergyIntoleranceMaxOrderByAggregateInput
    _min?: AllergyIntoleranceMinOrderByAggregateInput
  }

  export type AllergyIntoleranceScalarWhereWithAggregatesInput = {
    AND?: AllergyIntoleranceScalarWhereWithAggregatesInput | AllergyIntoleranceScalarWhereWithAggregatesInput[]
    OR?: AllergyIntoleranceScalarWhereWithAggregatesInput[]
    NOT?: AllergyIntoleranceScalarWhereWithAggregatesInput | AllergyIntoleranceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AllergyIntolerance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AllergyIntolerance"> | Date | string
    patientId?: StringWithAggregatesFilter<"AllergyIntolerance"> | string
    allergen?: StringWithAggregatesFilter<"AllergyIntolerance"> | string
    reaction?: StringNullableWithAggregatesFilter<"AllergyIntolerance"> | string | null
    severity?: StringNullableWithAggregatesFilter<"AllergyIntolerance"> | string | null
  }

  export type DocumentReferenceWhereInput = {
    AND?: DocumentReferenceWhereInput | DocumentReferenceWhereInput[]
    OR?: DocumentReferenceWhereInput[]
    NOT?: DocumentReferenceWhereInput | DocumentReferenceWhereInput[]
    id?: StringFilter<"DocumentReference"> | string
    createdAt?: DateTimeFilter<"DocumentReference"> | Date | string
    patientId?: StringFilter<"DocumentReference"> | string
    title?: StringFilter<"DocumentReference"> | string
    url?: StringFilter<"DocumentReference"> | string
    type?: StringFilter<"DocumentReference"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type DocumentReferenceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    url?: SortOrder
    type?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type DocumentReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentReferenceWhereInput | DocumentReferenceWhereInput[]
    OR?: DocumentReferenceWhereInput[]
    NOT?: DocumentReferenceWhereInput | DocumentReferenceWhereInput[]
    createdAt?: DateTimeFilter<"DocumentReference"> | Date | string
    patientId?: StringFilter<"DocumentReference"> | string
    title?: StringFilter<"DocumentReference"> | string
    url?: StringFilter<"DocumentReference"> | string
    type?: StringFilter<"DocumentReference"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type DocumentReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    url?: SortOrder
    type?: SortOrder
    _count?: DocumentReferenceCountOrderByAggregateInput
    _max?: DocumentReferenceMaxOrderByAggregateInput
    _min?: DocumentReferenceMinOrderByAggregateInput
  }

  export type DocumentReferenceScalarWhereWithAggregatesInput = {
    AND?: DocumentReferenceScalarWhereWithAggregatesInput | DocumentReferenceScalarWhereWithAggregatesInput[]
    OR?: DocumentReferenceScalarWhereWithAggregatesInput[]
    NOT?: DocumentReferenceScalarWhereWithAggregatesInput | DocumentReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentReference"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentReference"> | Date | string
    patientId?: StringWithAggregatesFilter<"DocumentReference"> | string
    title?: StringWithAggregatesFilter<"DocumentReference"> | string
    url?: StringWithAggregatesFilter<"DocumentReference"> | string
    type?: StringWithAggregatesFilter<"DocumentReference"> | string
  }

  export type ConditionWhereInput = {
    AND?: ConditionWhereInput | ConditionWhereInput[]
    OR?: ConditionWhereInput[]
    NOT?: ConditionWhereInput | ConditionWhereInput[]
    id?: StringFilter<"Condition"> | string
    createdAt?: DateTimeFilter<"Condition"> | Date | string
    patientId?: StringFilter<"Condition"> | string
    code?: StringFilter<"Condition"> | string
    name?: StringFilter<"Condition"> | string
    status?: StringFilter<"Condition"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type ConditionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConditionWhereInput | ConditionWhereInput[]
    OR?: ConditionWhereInput[]
    NOT?: ConditionWhereInput | ConditionWhereInput[]
    createdAt?: DateTimeFilter<"Condition"> | Date | string
    patientId?: StringFilter<"Condition"> | string
    code?: StringFilter<"Condition"> | string
    name?: StringFilter<"Condition"> | string
    status?: StringFilter<"Condition"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type ConditionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    _count?: ConditionCountOrderByAggregateInput
    _max?: ConditionMaxOrderByAggregateInput
    _min?: ConditionMinOrderByAggregateInput
  }

  export type ConditionScalarWhereWithAggregatesInput = {
    AND?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    OR?: ConditionScalarWhereWithAggregatesInput[]
    NOT?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Condition"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Condition"> | Date | string
    patientId?: StringWithAggregatesFilter<"Condition"> | string
    code?: StringWithAggregatesFilter<"Condition"> | string
    name?: StringWithAggregatesFilter<"Condition"> | string
    status?: StringWithAggregatesFilter<"Condition"> | string
  }

  export type ImmunizationWhereInput = {
    AND?: ImmunizationWhereInput | ImmunizationWhereInput[]
    OR?: ImmunizationWhereInput[]
    NOT?: ImmunizationWhereInput | ImmunizationWhereInput[]
    id?: StringFilter<"Immunization"> | string
    createdAt?: DateTimeFilter<"Immunization"> | Date | string
    patientId?: StringFilter<"Immunization"> | string
    vaccine?: StringFilter<"Immunization"> | string
    date?: DateTimeFilter<"Immunization"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type ImmunizationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    vaccine?: SortOrder
    date?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ImmunizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImmunizationWhereInput | ImmunizationWhereInput[]
    OR?: ImmunizationWhereInput[]
    NOT?: ImmunizationWhereInput | ImmunizationWhereInput[]
    createdAt?: DateTimeFilter<"Immunization"> | Date | string
    patientId?: StringFilter<"Immunization"> | string
    vaccine?: StringFilter<"Immunization"> | string
    date?: DateTimeFilter<"Immunization"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type ImmunizationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    vaccine?: SortOrder
    date?: SortOrder
    _count?: ImmunizationCountOrderByAggregateInput
    _max?: ImmunizationMaxOrderByAggregateInput
    _min?: ImmunizationMinOrderByAggregateInput
  }

  export type ImmunizationScalarWhereWithAggregatesInput = {
    AND?: ImmunizationScalarWhereWithAggregatesInput | ImmunizationScalarWhereWithAggregatesInput[]
    OR?: ImmunizationScalarWhereWithAggregatesInput[]
    NOT?: ImmunizationScalarWhereWithAggregatesInput | ImmunizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Immunization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Immunization"> | Date | string
    patientId?: StringWithAggregatesFilter<"Immunization"> | string
    vaccine?: StringWithAggregatesFilter<"Immunization"> | string
    date?: DateTimeWithAggregatesFilter<"Immunization"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutProfessionalInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutPerformedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutProfessionalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutPerformedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutProfessionalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutPerformedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutProfessionalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutPerformedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    cnpj?: string | null
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    cnpj?: string | null
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    cnpj?: string | null
    contact?: string | null
    email?: string | null
    phone?: string | null
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    batches?: ItemBatchCreateNestedManyWithoutItemInput
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    batches?: ItemBatchUncheckedCreateNestedManyWithoutItemInput
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ItemBatchUpdateManyWithoutItemNestedInput
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ItemBatchUncheckedUpdateManyWithoutItemNestedInput
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemBatchCreateInput = {
    id?: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutBatchesInput
    movements?: InventoryMovementCreateNestedManyWithoutBatchInput
  }

  export type ItemBatchUncheckedCreateInput = {
    id?: string
    itemId: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ItemBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBatchesNestedInput
    movements?: InventoryMovementUpdateManyWithoutBatchNestedInput
  }

  export type ItemBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type ItemBatchCreateManyInput = {
    id?: string
    itemId: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ItemBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutMovementsInput
    batch?: ItemBatchCreateNestedOneWithoutMovementsInput
    performedBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    itemId: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutMovementsNestedInput
    batch?: ItemBatchUpdateOneWithoutMovementsNestedInput
    performedBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    itemId: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    defaultDurationMin: number
    defaultItems: JsonNullValueInput | InputJsonValue
    procedures?: ProcedureCreateNestedManyWithoutProcedureTypeInput
  }

  export type ProcedureTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    defaultDurationMin: number
    defaultItems: JsonNullValueInput | InputJsonValue
    procedures?: ProcedureUncheckedCreateNestedManyWithoutProcedureTypeInput
  }

  export type ProcedureTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
    procedures?: ProcedureUpdateManyWithoutProcedureTypeNestedInput
  }

  export type ProcedureTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
    procedures?: ProcedureUncheckedUpdateManyWithoutProcedureTypeNestedInput
  }

  export type ProcedureTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    defaultDurationMin: number
    defaultItems: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureCreateInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutProceduresInput
    professional: UserCreateNestedOneWithoutProceduresInput
    procedureType: ProcedureTypeCreateNestedOneWithoutProceduresInput
    costSheet?: CostSheetCreateNestedOneWithoutProcedureInput
    payments?: PaymentCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateInput = {
    id?: string
    patientId: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    costSheet?: CostSheetUncheckedCreateNestedOneWithoutProcedureInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutProceduresNestedInput
    professional?: UserUpdateOneRequiredWithoutProceduresNestedInput
    procedureType?: ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput
    costSheet?: CostSheetUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    costSheet?: CostSheetUncheckedUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureCreateManyInput = {
    id?: string
    patientId: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
  }

  export type ProcedureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProcedureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostSheetCreateInput = {
    id?: string
    itemsCost: Decimal | DecimalJsLike | number | string
    laborCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginTarget: Decimal | DecimalJsLike | number | string
    suggestedPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    procedure: ProcedureCreateNestedOneWithoutCostSheetInput
  }

  export type CostSheetUncheckedCreateInput = {
    id?: string
    procedureId: string
    itemsCost: Decimal | DecimalJsLike | number | string
    laborCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginTarget: Decimal | DecimalJsLike | number | string
    suggestedPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostSheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedure?: ProcedureUpdateOneRequiredWithoutCostSheetNestedInput
  }

  export type CostSheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostSheetCreateManyInput = {
    id?: string
    procedureId: string
    itemsCost: Decimal | DecimalJsLike | number | string
    laborCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginTarget: Decimal | DecimalJsLike | number | string
    suggestedPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostSheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostSheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceRuleCreateInput = {
    id?: string
    scope: $Enums.PriceScope
    scopeId?: string | null
    marginTarget: Decimal | DecimalJsLike | number | string
    minMargin: Decimal | DecimalJsLike | number | string
    maxMargin: Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleUncheckedCreateInput = {
    id?: string
    scope: $Enums.PriceScope
    scopeId?: string | null
    marginTarget: Decimal | DecimalJsLike | number | string
    minMargin: Decimal | DecimalJsLike | number | string
    maxMargin: Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPriceScopeFieldUpdateOperationsInput | $Enums.PriceScope
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPriceScopeFieldUpdateOperationsInput | $Enums.PriceScope
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleCreateManyInput = {
    id?: string
    scope: $Enums.PriceScope
    scopeId?: string | null
    marginTarget: Decimal | DecimalJsLike | number | string
    minMargin: Decimal | DecimalJsLike | number | string
    maxMargin: Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPriceScopeFieldUpdateOperationsInput | $Enums.PriceScope
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PriceRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPriceScopeFieldUpdateOperationsInput | $Enums.PriceScope
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dynamicAdjustments?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
    procedure: ProcedureCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    procedureId: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    procedure?: ProcedureUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    procedureId: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
  }

  export type ClinicalNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
  }

  export type ClinicalNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ObservationCreateInput = {
    id?: string
    createdAt?: Date | string
    code: string
    value: string
    unit?: string | null
    patient: PatientCreateNestedOneWithoutObservationsInput
  }

  export type ObservationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    value: string
    unit?: string | null
  }

  export type ObservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    value: string
    unit?: string | null
  }

  export type ObservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionCreateInput = {
    id?: string
    createdAt?: Date | string
    medication: string
    dosage: string
    frequency: string
    patient: PatientCreateNestedOneWithoutMedicationsInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    medication: string
    dosage: string
    frequency: string
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    medication: string
    dosage: string
    frequency: string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosticReportCreateInput = {
    id?: string
    createdAt?: Date | string
    code: string
    result: string
    patient: PatientCreateNestedOneWithoutDiagnosticReportsInput
  }

  export type DiagnosticReportUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    result: string
  }

  export type DiagnosticReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutDiagnosticReportsNestedInput
  }

  export type DiagnosticReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosticReportCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    result: string
  }

  export type DiagnosticReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosticReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyIntoleranceCreateInput = {
    id?: string
    createdAt?: Date | string
    allergen: string
    reaction?: string | null
    severity?: string | null
    patient: PatientCreateNestedOneWithoutAllergiesInput
  }

  export type AllergyIntoleranceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    allergen: string
    reaction?: string | null
    severity?: string | null
  }

  export type AllergyIntoleranceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type AllergyIntoleranceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyIntoleranceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    allergen: string
    reaction?: string | null
    severity?: string | null
  }

  export type AllergyIntoleranceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyIntoleranceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReferenceCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    url: string
    type: string
    patient: PatientCreateNestedOneWithoutDocumentReferencesInput
  }

  export type DocumentReferenceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    title: string
    url: string
    type: string
  }

  export type DocumentReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutDocumentReferencesNestedInput
  }

  export type DocumentReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentReferenceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    title: string
    url: string
    type: string
  }

  export type DocumentReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionCreateInput = {
    id?: string
    createdAt?: Date | string
    code: string
    name: string
    status: string
    patient: PatientCreateNestedOneWithoutConditionsInput
  }

  export type ConditionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    name: string
    status: string
  }

  export type ConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type ConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    code: string
    name: string
    status: string
  }

  export type ConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ImmunizationCreateInput = {
    id?: string
    createdAt?: Date | string
    vaccine: string
    date: Date | string
    patient: PatientCreateNestedOneWithoutImmunizationsInput
  }

  export type ImmunizationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    vaccine: string
    date: Date | string
  }

  export type ImmunizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutImmunizationsNestedInput
  }

  export type ImmunizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    patientId: string
    vaccine: string
    date: Date | string
  }

  export type ImmunizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientId?: StringFieldUpdateOperationsInput | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProcedureListRelationFilter = {
    every?: ProcedureWhereInput
    some?: ProcedureWhereInput
    none?: ProcedureWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type ProcedureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ConditionListRelationFilter = {
    every?: ConditionWhereInput
    some?: ConditionWhereInput
    none?: ConditionWhereInput
  }

  export type AllergyIntoleranceListRelationFilter = {
    every?: AllergyIntoleranceWhereInput
    some?: AllergyIntoleranceWhereInput
    none?: AllergyIntoleranceWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type ImmunizationListRelationFilter = {
    every?: ImmunizationWhereInput
    some?: ImmunizationWhereInput
    none?: ImmunizationWhereInput
  }

  export type ClinicalNoteListRelationFilter = {
    every?: ClinicalNoteWhereInput
    some?: ClinicalNoteWhereInput
    none?: ClinicalNoteWhereInput
  }

  export type ObservationListRelationFilter = {
    every?: ObservationWhereInput
    some?: ObservationWhereInput
    none?: ObservationWhereInput
  }

  export type DiagnosticReportListRelationFilter = {
    every?: DiagnosticReportWhereInput
    some?: DiagnosticReportWhereInput
    none?: DiagnosticReportWhereInput
  }

  export type DocumentReferenceListRelationFilter = {
    every?: DocumentReferenceWhereInput
    some?: DocumentReferenceWhereInput
    none?: DocumentReferenceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllergyIntoleranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmunizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicalNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosticReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    consentGivenAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    consentGivenAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    consentGivenAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ItemBatchListRelationFilter = {
    every?: ItemBatchWhereInput
    some?: ItemBatchWhereInput
    none?: ItemBatchWhereInput
  }

  export type ItemBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    sku?: SortOrder
    minStock?: SortOrder
    isControlled?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    minStock?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    sku?: SortOrder
    minStock?: SortOrder
    isControlled?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    sku?: SortOrder
    minStock?: SortOrder
    isControlled?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    minStock?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemBatchCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchCode?: SortOrder
    expirationDate?: SortOrder
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemBatchAvgOrderByAggregateInput = {
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type ItemBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchCode?: SortOrder
    expirationDate?: SortOrder
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemBatchMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchCode?: SortOrder
    expirationDate?: SortOrder
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemBatchSumOrderByAggregateInput = {
    unitCost?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemBatchNullableScalarRelationFilter = {
    is?: ItemBatchWhereInput | null
    isNot?: ItemBatchWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    reason?: SortOrder
    linkedProcedureId?: SortOrder
    performedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    reason?: SortOrder
    linkedProcedureId?: SortOrder
    performedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    reason?: SortOrder
    linkedProcedureId?: SortOrder
    performedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProcedureTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDurationMin?: SortOrder
    defaultItems?: SortOrder
  }

  export type ProcedureTypeAvgOrderByAggregateInput = {
    defaultDurationMin?: SortOrder
  }

  export type ProcedureTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDurationMin?: SortOrder
  }

  export type ProcedureTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultDurationMin?: SortOrder
  }

  export type ProcedureTypeSumOrderByAggregateInput = {
    defaultDurationMin?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumProcedureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusFilter<$PrismaModel> | $Enums.ProcedureStatus
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type ProcedureTypeScalarRelationFilter = {
    is?: ProcedureTypeWhereInput
    isNot?: ProcedureTypeWhereInput
  }

  export type CostSheetNullableScalarRelationFilter = {
    is?: CostSheetWhereInput | null
    isNot?: CostSheetWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedureCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    professionalUserId?: SortOrder
    procedureTypeId?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    room?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ProcedureMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    professionalUserId?: SortOrder
    procedureTypeId?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    room?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ProcedureMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    professionalUserId?: SortOrder
    procedureTypeId?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    room?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type EnumProcedureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcedureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcedureStatusFilter<$PrismaModel>
    _max?: NestedEnumProcedureStatusFilter<$PrismaModel>
  }

  export type ProcedureScalarRelationFilter = {
    is?: ProcedureWhereInput
    isNot?: ProcedureWhereInput
  }

  export type CostSheetCountOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CostSheetAvgOrderByAggregateInput = {
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
  }

  export type CostSheetMaxOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CostSheetMinOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type CostSheetSumOrderByAggregateInput = {
    itemsCost?: SortOrder
    laborCost?: SortOrder
    overheadCost?: SortOrder
    totalCost?: SortOrder
    marginTarget?: SortOrder
    suggestedPrice?: SortOrder
  }

  export type EnumPriceScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceScope | EnumPriceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceScopeFilter<$PrismaModel> | $Enums.PriceScope
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PriceRuleCountOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    scopeId?: SortOrder
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
    dynamicAdjustments?: SortOrder
  }

  export type PriceRuleAvgOrderByAggregateInput = {
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
  }

  export type PriceRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    scopeId?: SortOrder
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
  }

  export type PriceRuleMinOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    scopeId?: SortOrder
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
  }

  export type PriceRuleSumOrderByAggregateInput = {
    marginTarget?: SortOrder
    minMargin?: SortOrder
    maxMargin?: SortOrder
  }

  export type EnumPriceScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceScope | EnumPriceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceScopeWithAggregatesFilter<$PrismaModel> | $Enums.PriceScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceScopeFilter<$PrismaModel>
    _max?: NestedEnumPriceScopeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    procedureId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    accessPurpose?: SortOrder
    justification?: SortOrder
    previousHash?: SortOrder
    currentHash?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    accessPurpose?: SortOrder
    justification?: SortOrder
    previousHash?: SortOrder
    currentHash?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    tenantId?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    accessPurpose?: SortOrder
    justification?: SortOrder
    previousHash?: SortOrder
    currentHash?: SortOrder
    timestamp?: SortOrder
  }

  export type ClinicalNoteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
  }

  export type ClinicalNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
  }

  export type ClinicalNoteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
  }

  export type ObservationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type ObservationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type ObservationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    medication?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    medication?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    medication?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
  }

  export type DiagnosticReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    result?: SortOrder
  }

  export type DiagnosticReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    result?: SortOrder
  }

  export type DiagnosticReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    result?: SortOrder
  }

  export type AllergyIntoleranceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    allergen?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
  }

  export type AllergyIntoleranceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    allergen?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
  }

  export type AllergyIntoleranceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    allergen?: SortOrder
    reaction?: SortOrder
    severity?: SortOrder
  }

  export type DocumentReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type DocumentReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type DocumentReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type ConditionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type ConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type ConditionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type ImmunizationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    vaccine?: SortOrder
    date?: SortOrder
  }

  export type ImmunizationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    vaccine?: SortOrder
    date?: SortOrder
  }

  export type ImmunizationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    patientId?: SortOrder
    vaccine?: SortOrder
    date?: SortOrder
  }

  export type ProcedureCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput> | ProcedureCreateWithoutProfessionalInput[] | ProcedureUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProfessionalInput | ProcedureCreateOrConnectWithoutProfessionalInput[]
    createMany?: ProcedureCreateManyProfessionalInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput> | InventoryMovementCreateWithoutPerformedByInput[] | InventoryMovementUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutPerformedByInput | InventoryMovementCreateOrConnectWithoutPerformedByInput[]
    createMany?: InventoryMovementCreateManyPerformedByInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput> | ProcedureCreateWithoutProfessionalInput[] | ProcedureUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProfessionalInput | ProcedureCreateOrConnectWithoutProfessionalInput[]
    createMany?: ProcedureCreateManyProfessionalInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput> | InventoryMovementCreateWithoutPerformedByInput[] | InventoryMovementUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutPerformedByInput | InventoryMovementCreateOrConnectWithoutPerformedByInput[]
    createMany?: InventoryMovementCreateManyPerformedByInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProcedureUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput> | ProcedureCreateWithoutProfessionalInput[] | ProcedureUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProfessionalInput | ProcedureCreateOrConnectWithoutProfessionalInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutProfessionalInput | ProcedureUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: ProcedureCreateManyProfessionalInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutProfessionalInput | ProcedureUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutProfessionalInput | ProcedureUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput> | InventoryMovementCreateWithoutPerformedByInput[] | InventoryMovementUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutPerformedByInput | InventoryMovementCreateOrConnectWithoutPerformedByInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutPerformedByInput | InventoryMovementUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: InventoryMovementCreateManyPerformedByInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutPerformedByInput | InventoryMovementUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutPerformedByInput | InventoryMovementUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput> | ProcedureCreateWithoutProfessionalInput[] | ProcedureUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProfessionalInput | ProcedureCreateOrConnectWithoutProfessionalInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutProfessionalInput | ProcedureUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: ProcedureCreateManyProfessionalInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutProfessionalInput | ProcedureUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutProfessionalInput | ProcedureUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput> | InventoryMovementCreateWithoutPerformedByInput[] | InventoryMovementUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutPerformedByInput | InventoryMovementCreateOrConnectWithoutPerformedByInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutPerformedByInput | InventoryMovementUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: InventoryMovementCreateManyPerformedByInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutPerformedByInput | InventoryMovementUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutPerformedByInput | InventoryMovementUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ProcedureCreateNestedManyWithoutPatientInput = {
    create?: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput> | ProcedureCreateWithoutPatientInput[] | ProcedureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutPatientInput | ProcedureCreateOrConnectWithoutPatientInput[]
    createMany?: ProcedureCreateManyPatientInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type ConditionCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput> | ConditionCreateWithoutPatientInput[] | ConditionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConditionCreateOrConnectWithoutPatientInput | ConditionCreateOrConnectWithoutPatientInput[]
    createMany?: ConditionCreateManyPatientInputEnvelope
    connect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
  }

  export type AllergyIntoleranceCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput> | AllergyIntoleranceCreateWithoutPatientInput[] | AllergyIntoleranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyIntoleranceCreateOrConnectWithoutPatientInput | AllergyIntoleranceCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyIntoleranceCreateManyPatientInputEnvelope
    connect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type ImmunizationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput> | ImmunizationCreateWithoutPatientInput[] | ImmunizationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ImmunizationCreateOrConnectWithoutPatientInput | ImmunizationCreateOrConnectWithoutPatientInput[]
    createMany?: ImmunizationCreateManyPatientInputEnvelope
    connect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ObservationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput> | ObservationCreateWithoutPatientInput[] | ObservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutPatientInput | ObservationCreateOrConnectWithoutPatientInput[]
    createMany?: ObservationCreateManyPatientInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type DiagnosticReportCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput> | DiagnosticReportCreateWithoutPatientInput[] | DiagnosticReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutPatientInput | DiagnosticReportCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosticReportCreateManyPatientInputEnvelope
    connect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
  }

  export type DocumentReferenceCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput> | DocumentReferenceCreateWithoutPatientInput[] | DocumentReferenceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentReferenceCreateOrConnectWithoutPatientInput | DocumentReferenceCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentReferenceCreateManyPatientInputEnvelope
    connect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput> | ProcedureCreateWithoutPatientInput[] | ProcedureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutPatientInput | ProcedureCreateOrConnectWithoutPatientInput[]
    createMany?: ProcedureCreateManyPatientInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type ConditionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput> | ConditionCreateWithoutPatientInput[] | ConditionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConditionCreateOrConnectWithoutPatientInput | ConditionCreateOrConnectWithoutPatientInput[]
    createMany?: ConditionCreateManyPatientInputEnvelope
    connect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
  }

  export type AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput> | AllergyIntoleranceCreateWithoutPatientInput[] | AllergyIntoleranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyIntoleranceCreateOrConnectWithoutPatientInput | AllergyIntoleranceCreateOrConnectWithoutPatientInput[]
    createMany?: AllergyIntoleranceCreateManyPatientInputEnvelope
    connect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type ImmunizationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput> | ImmunizationCreateWithoutPatientInput[] | ImmunizationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ImmunizationCreateOrConnectWithoutPatientInput | ImmunizationCreateOrConnectWithoutPatientInput[]
    createMany?: ImmunizationCreateManyPatientInputEnvelope
    connect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ObservationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput> | ObservationCreateWithoutPatientInput[] | ObservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutPatientInput | ObservationCreateOrConnectWithoutPatientInput[]
    createMany?: ObservationCreateManyPatientInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput> | DiagnosticReportCreateWithoutPatientInput[] | DiagnosticReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutPatientInput | DiagnosticReportCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosticReportCreateManyPatientInputEnvelope
    connect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
  }

  export type DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput> | DocumentReferenceCreateWithoutPatientInput[] | DocumentReferenceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentReferenceCreateOrConnectWithoutPatientInput | DocumentReferenceCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentReferenceCreateManyPatientInputEnvelope
    connect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProcedureUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput> | ProcedureCreateWithoutPatientInput[] | ProcedureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutPatientInput | ProcedureCreateOrConnectWithoutPatientInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutPatientInput | ProcedureUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ProcedureCreateManyPatientInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutPatientInput | ProcedureUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutPatientInput | ProcedureUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type ConditionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput> | ConditionCreateWithoutPatientInput[] | ConditionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConditionCreateOrConnectWithoutPatientInput | ConditionCreateOrConnectWithoutPatientInput[]
    upsert?: ConditionUpsertWithWhereUniqueWithoutPatientInput | ConditionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConditionCreateManyPatientInputEnvelope
    set?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    disconnect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    delete?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    connect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    update?: ConditionUpdateWithWhereUniqueWithoutPatientInput | ConditionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConditionUpdateManyWithWhereWithoutPatientInput | ConditionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConditionScalarWhereInput | ConditionScalarWhereInput[]
  }

  export type AllergyIntoleranceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput> | AllergyIntoleranceCreateWithoutPatientInput[] | AllergyIntoleranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyIntoleranceCreateOrConnectWithoutPatientInput | AllergyIntoleranceCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyIntoleranceUpsertWithWhereUniqueWithoutPatientInput | AllergyIntoleranceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyIntoleranceCreateManyPatientInputEnvelope
    set?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    disconnect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    delete?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    connect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    update?: AllergyIntoleranceUpdateWithWhereUniqueWithoutPatientInput | AllergyIntoleranceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyIntoleranceUpdateManyWithWhereWithoutPatientInput | AllergyIntoleranceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyIntoleranceScalarWhereInput | AllergyIntoleranceScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type ImmunizationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput> | ImmunizationCreateWithoutPatientInput[] | ImmunizationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ImmunizationCreateOrConnectWithoutPatientInput | ImmunizationCreateOrConnectWithoutPatientInput[]
    upsert?: ImmunizationUpsertWithWhereUniqueWithoutPatientInput | ImmunizationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ImmunizationCreateManyPatientInputEnvelope
    set?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    disconnect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    delete?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    connect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    update?: ImmunizationUpdateWithWhereUniqueWithoutPatientInput | ImmunizationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ImmunizationUpdateManyWithWhereWithoutPatientInput | ImmunizationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ImmunizationScalarWhereInput | ImmunizationScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ObservationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput> | ObservationCreateWithoutPatientInput[] | ObservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutPatientInput | ObservationCreateOrConnectWithoutPatientInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutPatientInput | ObservationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ObservationCreateManyPatientInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutPatientInput | ObservationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutPatientInput | ObservationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type DiagnosticReportUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput> | DiagnosticReportCreateWithoutPatientInput[] | DiagnosticReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutPatientInput | DiagnosticReportCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosticReportUpsertWithWhereUniqueWithoutPatientInput | DiagnosticReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosticReportCreateManyPatientInputEnvelope
    set?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    disconnect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    delete?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    connect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    update?: DiagnosticReportUpdateWithWhereUniqueWithoutPatientInput | DiagnosticReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosticReportUpdateManyWithWhereWithoutPatientInput | DiagnosticReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosticReportScalarWhereInput | DiagnosticReportScalarWhereInput[]
  }

  export type DocumentReferenceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput> | DocumentReferenceCreateWithoutPatientInput[] | DocumentReferenceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentReferenceCreateOrConnectWithoutPatientInput | DocumentReferenceCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentReferenceUpsertWithWhereUniqueWithoutPatientInput | DocumentReferenceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentReferenceCreateManyPatientInputEnvelope
    set?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    disconnect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    delete?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    connect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    update?: DocumentReferenceUpdateWithWhereUniqueWithoutPatientInput | DocumentReferenceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentReferenceUpdateManyWithWhereWithoutPatientInput | DocumentReferenceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentReferenceScalarWhereInput | DocumentReferenceScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput> | ProcedureCreateWithoutPatientInput[] | ProcedureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutPatientInput | ProcedureCreateOrConnectWithoutPatientInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutPatientInput | ProcedureUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ProcedureCreateManyPatientInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutPatientInput | ProcedureUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutPatientInput | ProcedureUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type ConditionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput> | ConditionCreateWithoutPatientInput[] | ConditionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConditionCreateOrConnectWithoutPatientInput | ConditionCreateOrConnectWithoutPatientInput[]
    upsert?: ConditionUpsertWithWhereUniqueWithoutPatientInput | ConditionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConditionCreateManyPatientInputEnvelope
    set?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    disconnect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    delete?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    connect?: ConditionWhereUniqueInput | ConditionWhereUniqueInput[]
    update?: ConditionUpdateWithWhereUniqueWithoutPatientInput | ConditionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConditionUpdateManyWithWhereWithoutPatientInput | ConditionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConditionScalarWhereInput | ConditionScalarWhereInput[]
  }

  export type AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput> | AllergyIntoleranceCreateWithoutPatientInput[] | AllergyIntoleranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergyIntoleranceCreateOrConnectWithoutPatientInput | AllergyIntoleranceCreateOrConnectWithoutPatientInput[]
    upsert?: AllergyIntoleranceUpsertWithWhereUniqueWithoutPatientInput | AllergyIntoleranceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergyIntoleranceCreateManyPatientInputEnvelope
    set?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    disconnect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    delete?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    connect?: AllergyIntoleranceWhereUniqueInput | AllergyIntoleranceWhereUniqueInput[]
    update?: AllergyIntoleranceUpdateWithWhereUniqueWithoutPatientInput | AllergyIntoleranceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergyIntoleranceUpdateManyWithWhereWithoutPatientInput | AllergyIntoleranceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergyIntoleranceScalarWhereInput | AllergyIntoleranceScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type ImmunizationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput> | ImmunizationCreateWithoutPatientInput[] | ImmunizationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ImmunizationCreateOrConnectWithoutPatientInput | ImmunizationCreateOrConnectWithoutPatientInput[]
    upsert?: ImmunizationUpsertWithWhereUniqueWithoutPatientInput | ImmunizationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ImmunizationCreateManyPatientInputEnvelope
    set?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    disconnect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    delete?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    connect?: ImmunizationWhereUniqueInput | ImmunizationWhereUniqueInput[]
    update?: ImmunizationUpdateWithWhereUniqueWithoutPatientInput | ImmunizationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ImmunizationUpdateManyWithWhereWithoutPatientInput | ImmunizationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ImmunizationScalarWhereInput | ImmunizationScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ObservationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput> | ObservationCreateWithoutPatientInput[] | ObservationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutPatientInput | ObservationCreateOrConnectWithoutPatientInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutPatientInput | ObservationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ObservationCreateManyPatientInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutPatientInput | ObservationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutPatientInput | ObservationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput> | DiagnosticReportCreateWithoutPatientInput[] | DiagnosticReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosticReportCreateOrConnectWithoutPatientInput | DiagnosticReportCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosticReportUpsertWithWhereUniqueWithoutPatientInput | DiagnosticReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosticReportCreateManyPatientInputEnvelope
    set?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    disconnect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    delete?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    connect?: DiagnosticReportWhereUniqueInput | DiagnosticReportWhereUniqueInput[]
    update?: DiagnosticReportUpdateWithWhereUniqueWithoutPatientInput | DiagnosticReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosticReportUpdateManyWithWhereWithoutPatientInput | DiagnosticReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosticReportScalarWhereInput | DiagnosticReportScalarWhereInput[]
  }

  export type DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput> | DocumentReferenceCreateWithoutPatientInput[] | DocumentReferenceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentReferenceCreateOrConnectWithoutPatientInput | DocumentReferenceCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentReferenceUpsertWithWhereUniqueWithoutPatientInput | DocumentReferenceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentReferenceCreateManyPatientInputEnvelope
    set?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    disconnect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    delete?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    connect?: DocumentReferenceWhereUniqueInput | DocumentReferenceWhereUniqueInput[]
    update?: DocumentReferenceUpdateWithWhereUniqueWithoutPatientInput | DocumentReferenceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentReferenceUpdateManyWithWhereWithoutPatientInput | DocumentReferenceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentReferenceScalarWhereInput | DocumentReferenceScalarWhereInput[]
  }

  export type ItemBatchCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput> | ItemBatchCreateWithoutItemInput[] | ItemBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemBatchCreateOrConnectWithoutItemInput | ItemBatchCreateOrConnectWithoutItemInput[]
    createMany?: ItemBatchCreateManyItemInputEnvelope
    connect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ItemBatchUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput> | ItemBatchCreateWithoutItemInput[] | ItemBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemBatchCreateOrConnectWithoutItemInput | ItemBatchCreateOrConnectWithoutItemInput[]
    createMany?: ItemBatchCreateManyItemInputEnvelope
    connect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ItemBatchUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput> | ItemBatchCreateWithoutItemInput[] | ItemBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemBatchCreateOrConnectWithoutItemInput | ItemBatchCreateOrConnectWithoutItemInput[]
    upsert?: ItemBatchUpsertWithWhereUniqueWithoutItemInput | ItemBatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemBatchCreateManyItemInputEnvelope
    set?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    disconnect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    delete?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    connect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    update?: ItemBatchUpdateWithWhereUniqueWithoutItemInput | ItemBatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemBatchUpdateManyWithWhereWithoutItemInput | ItemBatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemBatchScalarWhereInput | ItemBatchScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ItemBatchUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput> | ItemBatchCreateWithoutItemInput[] | ItemBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemBatchCreateOrConnectWithoutItemInput | ItemBatchCreateOrConnectWithoutItemInput[]
    upsert?: ItemBatchUpsertWithWhereUniqueWithoutItemInput | ItemBatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemBatchCreateManyItemInputEnvelope
    set?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    disconnect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    delete?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    connect?: ItemBatchWhereUniqueInput | ItemBatchWhereUniqueInput[]
    update?: ItemBatchUpdateWithWhereUniqueWithoutItemInput | ItemBatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemBatchUpdateManyWithWhereWithoutItemInput | ItemBatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemBatchScalarWhereInput | ItemBatchScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutBatchesInput = {
    create?: XOR<ItemCreateWithoutBatchesInput, ItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBatchesInput
    connect?: ItemWhereUniqueInput
  }

  export type InventoryMovementCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput> | InventoryMovementCreateWithoutBatchInput[] | InventoryMovementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutBatchInput | InventoryMovementCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryMovementCreateManyBatchInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput> | InventoryMovementCreateWithoutBatchInput[] | InventoryMovementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutBatchInput | InventoryMovementCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryMovementCreateManyBatchInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ItemUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<ItemCreateWithoutBatchesInput, ItemUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBatchesInput
    upsert?: ItemUpsertWithoutBatchesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBatchesInput, ItemUpdateWithoutBatchesInput>, ItemUncheckedUpdateWithoutBatchesInput>
  }

  export type InventoryMovementUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput> | InventoryMovementCreateWithoutBatchInput[] | InventoryMovementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutBatchInput | InventoryMovementCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutBatchInput | InventoryMovementUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryMovementCreateManyBatchInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutBatchInput | InventoryMovementUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutBatchInput | InventoryMovementUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput> | InventoryMovementCreateWithoutBatchInput[] | InventoryMovementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutBatchInput | InventoryMovementCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutBatchInput | InventoryMovementUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryMovementCreateManyBatchInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutBatchInput | InventoryMovementUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutBatchInput | InventoryMovementUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutMovementsInput = {
    create?: XOR<ItemCreateWithoutMovementsInput, ItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMovementsInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemBatchCreateNestedOneWithoutMovementsInput = {
    create?: XOR<ItemBatchCreateWithoutMovementsInput, ItemBatchUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ItemBatchCreateOrConnectWithoutMovementsInput
    connect?: ItemBatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MovementType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ItemUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<ItemCreateWithoutMovementsInput, ItemUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutMovementsInput
    upsert?: ItemUpsertWithoutMovementsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutMovementsInput, ItemUpdateWithoutMovementsInput>, ItemUncheckedUpdateWithoutMovementsInput>
  }

  export type ItemBatchUpdateOneWithoutMovementsNestedInput = {
    create?: XOR<ItemBatchCreateWithoutMovementsInput, ItemBatchUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: ItemBatchCreateOrConnectWithoutMovementsInput
    upsert?: ItemBatchUpsertWithoutMovementsInput
    disconnect?: ItemBatchWhereInput | boolean
    delete?: ItemBatchWhereInput | boolean
    connect?: ItemBatchWhereUniqueInput
    update?: XOR<XOR<ItemBatchUpdateToOneWithWhereWithoutMovementsInput, ItemBatchUpdateWithoutMovementsInput>, ItemBatchUncheckedUpdateWithoutMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    upsert?: UserUpsertWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryMovementsInput, UserUpdateWithoutInventoryMovementsInput>, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProcedureCreateNestedManyWithoutProcedureTypeInput = {
    create?: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput> | ProcedureCreateWithoutProcedureTypeInput[] | ProcedureUncheckedCreateWithoutProcedureTypeInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProcedureTypeInput | ProcedureCreateOrConnectWithoutProcedureTypeInput[]
    createMany?: ProcedureCreateManyProcedureTypeInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type ProcedureUncheckedCreateNestedManyWithoutProcedureTypeInput = {
    create?: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput> | ProcedureCreateWithoutProcedureTypeInput[] | ProcedureUncheckedCreateWithoutProcedureTypeInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProcedureTypeInput | ProcedureCreateOrConnectWithoutProcedureTypeInput[]
    createMany?: ProcedureCreateManyProcedureTypeInputEnvelope
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProcedureUpdateManyWithoutProcedureTypeNestedInput = {
    create?: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput> | ProcedureCreateWithoutProcedureTypeInput[] | ProcedureUncheckedCreateWithoutProcedureTypeInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProcedureTypeInput | ProcedureCreateOrConnectWithoutProcedureTypeInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutProcedureTypeInput | ProcedureUpsertWithWhereUniqueWithoutProcedureTypeInput[]
    createMany?: ProcedureCreateManyProcedureTypeInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutProcedureTypeInput | ProcedureUpdateWithWhereUniqueWithoutProcedureTypeInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutProcedureTypeInput | ProcedureUpdateManyWithWhereWithoutProcedureTypeInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type ProcedureUncheckedUpdateManyWithoutProcedureTypeNestedInput = {
    create?: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput> | ProcedureCreateWithoutProcedureTypeInput[] | ProcedureUncheckedCreateWithoutProcedureTypeInput[]
    connectOrCreate?: ProcedureCreateOrConnectWithoutProcedureTypeInput | ProcedureCreateOrConnectWithoutProcedureTypeInput[]
    upsert?: ProcedureUpsertWithWhereUniqueWithoutProcedureTypeInput | ProcedureUpsertWithWhereUniqueWithoutProcedureTypeInput[]
    createMany?: ProcedureCreateManyProcedureTypeInputEnvelope
    set?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    disconnect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    delete?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    connect?: ProcedureWhereUniqueInput | ProcedureWhereUniqueInput[]
    update?: ProcedureUpdateWithWhereUniqueWithoutProcedureTypeInput | ProcedureUpdateWithWhereUniqueWithoutProcedureTypeInput[]
    updateMany?: ProcedureUpdateManyWithWhereWithoutProcedureTypeInput | ProcedureUpdateManyWithWhereWithoutProcedureTypeInput[]
    deleteMany?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutProceduresInput = {
    create?: XOR<PatientCreateWithoutProceduresInput, PatientUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: PatientCreateOrConnectWithoutProceduresInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProceduresInput = {
    create?: XOR<UserCreateWithoutProceduresInput, UserUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: UserCreateOrConnectWithoutProceduresInput
    connect?: UserWhereUniqueInput
  }

  export type ProcedureTypeCreateNestedOneWithoutProceduresInput = {
    create?: XOR<ProcedureTypeCreateWithoutProceduresInput, ProcedureTypeUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: ProcedureTypeCreateOrConnectWithoutProceduresInput
    connect?: ProcedureTypeWhereUniqueInput
  }

  export type CostSheetCreateNestedOneWithoutProcedureInput = {
    create?: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
    connectOrCreate?: CostSheetCreateOrConnectWithoutProcedureInput
    connect?: CostSheetWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutProcedureInput = {
    create?: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput> | PaymentCreateWithoutProcedureInput[] | PaymentUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProcedureInput | PaymentCreateOrConnectWithoutProcedureInput[]
    createMany?: PaymentCreateManyProcedureInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CostSheetUncheckedCreateNestedOneWithoutProcedureInput = {
    create?: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
    connectOrCreate?: CostSheetCreateOrConnectWithoutProcedureInput
    connect?: CostSheetWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput> | PaymentCreateWithoutProcedureInput[] | PaymentUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProcedureInput | PaymentCreateOrConnectWithoutProcedureInput[]
    createMany?: PaymentCreateManyProcedureInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumProcedureStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcedureStatus
  }

  export type PatientUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<PatientCreateWithoutProceduresInput, PatientUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: PatientCreateOrConnectWithoutProceduresInput
    upsert?: PatientUpsertWithoutProceduresInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutProceduresInput, PatientUpdateWithoutProceduresInput>, PatientUncheckedUpdateWithoutProceduresInput>
  }

  export type UserUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<UserCreateWithoutProceduresInput, UserUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: UserCreateOrConnectWithoutProceduresInput
    upsert?: UserUpsertWithoutProceduresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProceduresInput, UserUpdateWithoutProceduresInput>, UserUncheckedUpdateWithoutProceduresInput>
  }

  export type ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput = {
    create?: XOR<ProcedureTypeCreateWithoutProceduresInput, ProcedureTypeUncheckedCreateWithoutProceduresInput>
    connectOrCreate?: ProcedureTypeCreateOrConnectWithoutProceduresInput
    upsert?: ProcedureTypeUpsertWithoutProceduresInput
    connect?: ProcedureTypeWhereUniqueInput
    update?: XOR<XOR<ProcedureTypeUpdateToOneWithWhereWithoutProceduresInput, ProcedureTypeUpdateWithoutProceduresInput>, ProcedureTypeUncheckedUpdateWithoutProceduresInput>
  }

  export type CostSheetUpdateOneWithoutProcedureNestedInput = {
    create?: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
    connectOrCreate?: CostSheetCreateOrConnectWithoutProcedureInput
    upsert?: CostSheetUpsertWithoutProcedureInput
    disconnect?: CostSheetWhereInput | boolean
    delete?: CostSheetWhereInput | boolean
    connect?: CostSheetWhereUniqueInput
    update?: XOR<XOR<CostSheetUpdateToOneWithWhereWithoutProcedureInput, CostSheetUpdateWithoutProcedureInput>, CostSheetUncheckedUpdateWithoutProcedureInput>
  }

  export type PaymentUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput> | PaymentCreateWithoutProcedureInput[] | PaymentUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProcedureInput | PaymentCreateOrConnectWithoutProcedureInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProcedureInput | PaymentUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: PaymentCreateManyProcedureInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProcedureInput | PaymentUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProcedureInput | PaymentUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CostSheetUncheckedUpdateOneWithoutProcedureNestedInput = {
    create?: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
    connectOrCreate?: CostSheetCreateOrConnectWithoutProcedureInput
    upsert?: CostSheetUpsertWithoutProcedureInput
    disconnect?: CostSheetWhereInput | boolean
    delete?: CostSheetWhereInput | boolean
    connect?: CostSheetWhereUniqueInput
    update?: XOR<XOR<CostSheetUpdateToOneWithWhereWithoutProcedureInput, CostSheetUpdateWithoutProcedureInput>, CostSheetUncheckedUpdateWithoutProcedureInput>
  }

  export type PaymentUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput> | PaymentCreateWithoutProcedureInput[] | PaymentUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProcedureInput | PaymentCreateOrConnectWithoutProcedureInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProcedureInput | PaymentUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: PaymentCreateManyProcedureInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProcedureInput | PaymentUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProcedureInput | PaymentUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProcedureCreateNestedOneWithoutCostSheetInput = {
    create?: XOR<ProcedureCreateWithoutCostSheetInput, ProcedureUncheckedCreateWithoutCostSheetInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutCostSheetInput
    connect?: ProcedureWhereUniqueInput
  }

  export type ProcedureUpdateOneRequiredWithoutCostSheetNestedInput = {
    create?: XOR<ProcedureCreateWithoutCostSheetInput, ProcedureUncheckedCreateWithoutCostSheetInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutCostSheetInput
    upsert?: ProcedureUpsertWithoutCostSheetInput
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutCostSheetInput, ProcedureUpdateWithoutCostSheetInput>, ProcedureUncheckedUpdateWithoutCostSheetInput>
  }

  export type EnumPriceScopeFieldUpdateOperationsInput = {
    set?: $Enums.PriceScope
  }

  export type ProcedureCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ProcedureCreateWithoutPaymentsInput, ProcedureUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutPaymentsInput
    connect?: ProcedureWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ProcedureUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ProcedureCreateWithoutPaymentsInput, ProcedureUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutPaymentsInput
    upsert?: ProcedureUpsertWithoutPaymentsInput
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutPaymentsInput, ProcedureUpdateWithoutPaymentsInput>, ProcedureUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type PatientCreateNestedOneWithoutClinicalNotesInput = {
    create?: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutClinicalNotesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutClinicalNotesNestedInput = {
    create?: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutClinicalNotesInput
    upsert?: PatientUpsertWithoutClinicalNotesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutClinicalNotesInput, PatientUpdateWithoutClinicalNotesInput>, PatientUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type PatientCreateNestedOneWithoutObservationsInput = {
    create?: XOR<PatientCreateWithoutObservationsInput, PatientUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutObservationsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutObservationsNestedInput = {
    create?: XOR<PatientCreateWithoutObservationsInput, PatientUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutObservationsInput
    upsert?: PatientUpsertWithoutObservationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutObservationsInput, PatientUpdateWithoutObservationsInput>, PatientUncheckedUpdateWithoutObservationsInput>
  }

  export type PatientCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationsInput
    upsert?: PatientUpsertWithoutMedicationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicationsInput, PatientUpdateWithoutMedicationsInput>, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type PatientCreateNestedOneWithoutDiagnosticReportsInput = {
    create?: XOR<PatientCreateWithoutDiagnosticReportsInput, PatientUncheckedCreateWithoutDiagnosticReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDiagnosticReportsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutDiagnosticReportsNestedInput = {
    create?: XOR<PatientCreateWithoutDiagnosticReportsInput, PatientUncheckedCreateWithoutDiagnosticReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDiagnosticReportsInput
    upsert?: PatientUpsertWithoutDiagnosticReportsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDiagnosticReportsInput, PatientUpdateWithoutDiagnosticReportsInput>, PatientUncheckedUpdateWithoutDiagnosticReportsInput>
  }

  export type PatientCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    upsert?: PatientUpsertWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAllergiesInput, PatientUpdateWithoutAllergiesInput>, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientCreateNestedOneWithoutDocumentReferencesInput = {
    create?: XOR<PatientCreateWithoutDocumentReferencesInput, PatientUncheckedCreateWithoutDocumentReferencesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentReferencesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutDocumentReferencesNestedInput = {
    create?: XOR<PatientCreateWithoutDocumentReferencesInput, PatientUncheckedCreateWithoutDocumentReferencesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentReferencesInput
    upsert?: PatientUpsertWithoutDocumentReferencesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDocumentReferencesInput, PatientUpdateWithoutDocumentReferencesInput>, PatientUncheckedUpdateWithoutDocumentReferencesInput>
  }

  export type PatientCreateNestedOneWithoutConditionsInput = {
    create?: XOR<PatientCreateWithoutConditionsInput, PatientUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConditionsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<PatientCreateWithoutConditionsInput, PatientUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConditionsInput
    upsert?: PatientUpsertWithoutConditionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConditionsInput, PatientUpdateWithoutConditionsInput>, PatientUncheckedUpdateWithoutConditionsInput>
  }

  export type PatientCreateNestedOneWithoutImmunizationsInput = {
    create?: XOR<PatientCreateWithoutImmunizationsInput, PatientUncheckedCreateWithoutImmunizationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutImmunizationsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutImmunizationsNestedInput = {
    create?: XOR<PatientCreateWithoutImmunizationsInput, PatientUncheckedCreateWithoutImmunizationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutImmunizationsInput
    upsert?: PatientUpsertWithoutImmunizationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutImmunizationsInput, PatientUpdateWithoutImmunizationsInput>, PatientUncheckedUpdateWithoutImmunizationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProcedureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusFilter<$PrismaModel> | $Enums.ProcedureStatus
  }

  export type NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcedureStatus | EnumProcedureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcedureStatus[] | ListEnumProcedureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcedureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcedureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcedureStatusFilter<$PrismaModel>
    _max?: NestedEnumProcedureStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriceScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceScope | EnumPriceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceScopeFilter<$PrismaModel> | $Enums.PriceScope
  }

  export type NestedEnumPriceScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceScope | EnumPriceScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriceScope[] | ListEnumPriceScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPriceScopeWithAggregatesFilter<$PrismaModel> | $Enums.PriceScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriceScopeFilter<$PrismaModel>
    _max?: NestedEnumPriceScopeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ProcedureCreateWithoutProfessionalInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutProceduresInput
    procedureType: ProcedureTypeCreateNestedOneWithoutProceduresInput
    costSheet?: CostSheetCreateNestedOneWithoutProcedureInput
    payments?: PaymentCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutProfessionalInput = {
    id?: string
    patientId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    costSheet?: CostSheetUncheckedCreateNestedOneWithoutProcedureInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutProfessionalInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput>
  }

  export type ProcedureCreateManyProfessionalInputEnvelope = {
    data: ProcedureCreateManyProfessionalInput | ProcedureCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutPerformedByInput = {
    id?: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutMovementsInput
    batch?: ItemBatchCreateNestedOneWithoutMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutPerformedByInput = {
    id?: string
    itemId: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutPerformedByInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput>
  }

  export type InventoryMovementCreateManyPerformedByInputEnvelope = {
    data: InventoryMovementCreateManyPerformedByInput | InventoryMovementCreateManyPerformedByInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutProfessionalInput, ProcedureUncheckedUpdateWithoutProfessionalInput>
    create: XOR<ProcedureCreateWithoutProfessionalInput, ProcedureUncheckedCreateWithoutProfessionalInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutProfessionalInput, ProcedureUncheckedUpdateWithoutProfessionalInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutProfessionalInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type ProcedureScalarWhereInput = {
    AND?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    OR?: ProcedureScalarWhereInput[]
    NOT?: ProcedureScalarWhereInput | ProcedureScalarWhereInput[]
    id?: StringFilter<"Procedure"> | string
    patientId?: StringFilter<"Procedure"> | string
    professionalUserId?: StringFilter<"Procedure"> | string
    procedureTypeId?: StringFilter<"Procedure"> | string
    scheduledAt?: DateTimeFilter<"Procedure"> | Date | string
    startedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"Procedure"> | Date | string | null
    room?: StringNullableFilter<"Procedure"> | string | null
    status?: EnumProcedureStatusFilter<"Procedure"> | $Enums.ProcedureStatus
    notes?: StringNullableFilter<"Procedure"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    userRole?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    resourceType?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    description?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    accessPurpose?: StringNullableFilter<"AuditLog"> | string | null
    justification?: StringNullableFilter<"AuditLog"> | string | null
    previousHash?: StringNullableFilter<"AuditLog"> | string | null
    currentHash?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutPerformedByInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutPerformedByInput, InventoryMovementUncheckedUpdateWithoutPerformedByInput>
    create: XOR<InventoryMovementCreateWithoutPerformedByInput, InventoryMovementUncheckedCreateWithoutPerformedByInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutPerformedByInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutPerformedByInput, InventoryMovementUncheckedUpdateWithoutPerformedByInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutPerformedByInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutPerformedByInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    itemId?: StringFilter<"InventoryMovement"> | string
    batchId?: StringNullableFilter<"InventoryMovement"> | string | null
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: DecimalFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    linkedProcedureId?: StringNullableFilter<"InventoryMovement"> | string | null
    performedByUserId?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type ProcedureCreateWithoutPatientInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    professional: UserCreateNestedOneWithoutProceduresInput
    procedureType: ProcedureTypeCreateNestedOneWithoutProceduresInput
    costSheet?: CostSheetCreateNestedOneWithoutProcedureInput
    payments?: PaymentCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutPatientInput = {
    id?: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    costSheet?: CostSheetUncheckedCreateNestedOneWithoutProcedureInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutPatientInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput>
  }

  export type ProcedureCreateManyPatientInputEnvelope = {
    data: ProcedureCreateManyPatientInput | ProcedureCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConditionCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    name: string
    status: string
  }

  export type ConditionUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    name: string
    status: string
  }

  export type ConditionCreateOrConnectWithoutPatientInput = {
    where: ConditionWhereUniqueInput
    create: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput>
  }

  export type ConditionCreateManyPatientInputEnvelope = {
    data: ConditionCreateManyPatientInput | ConditionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AllergyIntoleranceCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    allergen: string
    reaction?: string | null
    severity?: string | null
  }

  export type AllergyIntoleranceUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    allergen: string
    reaction?: string | null
    severity?: string | null
  }

  export type AllergyIntoleranceCreateOrConnectWithoutPatientInput = {
    where: AllergyIntoleranceWhereUniqueInput
    create: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput>
  }

  export type AllergyIntoleranceCreateManyPatientInputEnvelope = {
    data: AllergyIntoleranceCreateManyPatientInput | AllergyIntoleranceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    medication: string
    dosage: string
    frequency: string
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    medication: string
    dosage: string
    frequency: string
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ImmunizationCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    vaccine: string
    date: Date | string
  }

  export type ImmunizationUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    vaccine: string
    date: Date | string
  }

  export type ImmunizationCreateOrConnectWithoutPatientInput = {
    where: ImmunizationWhereUniqueInput
    create: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput>
  }

  export type ImmunizationCreateManyPatientInputEnvelope = {
    data: ImmunizationCreateManyPatientInput | ImmunizationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
  }

  export type ClinicalNoteUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
  }

  export type ClinicalNoteCreateOrConnectWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteCreateManyPatientInputEnvelope = {
    data: ClinicalNoteCreateManyPatientInput | ClinicalNoteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ObservationCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    value: string
    unit?: string | null
  }

  export type ObservationUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    value: string
    unit?: string | null
  }

  export type ObservationCreateOrConnectWithoutPatientInput = {
    where: ObservationWhereUniqueInput
    create: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput>
  }

  export type ObservationCreateManyPatientInputEnvelope = {
    data: ObservationCreateManyPatientInput | ObservationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosticReportCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    result: string
  }

  export type DiagnosticReportUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    result: string
  }

  export type DiagnosticReportCreateOrConnectWithoutPatientInput = {
    where: DiagnosticReportWhereUniqueInput
    create: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosticReportCreateManyPatientInputEnvelope = {
    data: DiagnosticReportCreateManyPatientInput | DiagnosticReportCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentReferenceCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    title: string
    url: string
    type: string
  }

  export type DocumentReferenceUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    title: string
    url: string
    type: string
  }

  export type DocumentReferenceCreateOrConnectWithoutPatientInput = {
    where: DocumentReferenceWhereUniqueInput
    create: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput>
  }

  export type DocumentReferenceCreateManyPatientInputEnvelope = {
    data: DocumentReferenceCreateManyPatientInput | DocumentReferenceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureUpsertWithWhereUniqueWithoutPatientInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutPatientInput, ProcedureUncheckedUpdateWithoutPatientInput>
    create: XOR<ProcedureCreateWithoutPatientInput, ProcedureUncheckedCreateWithoutPatientInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutPatientInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutPatientInput, ProcedureUncheckedUpdateWithoutPatientInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutPatientInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConditionUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConditionWhereUniqueInput
    update: XOR<ConditionUpdateWithoutPatientInput, ConditionUncheckedUpdateWithoutPatientInput>
    create: XOR<ConditionCreateWithoutPatientInput, ConditionUncheckedCreateWithoutPatientInput>
  }

  export type ConditionUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConditionWhereUniqueInput
    data: XOR<ConditionUpdateWithoutPatientInput, ConditionUncheckedUpdateWithoutPatientInput>
  }

  export type ConditionUpdateManyWithWhereWithoutPatientInput = {
    where: ConditionScalarWhereInput
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConditionScalarWhereInput = {
    AND?: ConditionScalarWhereInput | ConditionScalarWhereInput[]
    OR?: ConditionScalarWhereInput[]
    NOT?: ConditionScalarWhereInput | ConditionScalarWhereInput[]
    id?: StringFilter<"Condition"> | string
    createdAt?: DateTimeFilter<"Condition"> | Date | string
    patientId?: StringFilter<"Condition"> | string
    code?: StringFilter<"Condition"> | string
    name?: StringFilter<"Condition"> | string
    status?: StringFilter<"Condition"> | string
  }

  export type AllergyIntoleranceUpsertWithWhereUniqueWithoutPatientInput = {
    where: AllergyIntoleranceWhereUniqueInput
    update: XOR<AllergyIntoleranceUpdateWithoutPatientInput, AllergyIntoleranceUncheckedUpdateWithoutPatientInput>
    create: XOR<AllergyIntoleranceCreateWithoutPatientInput, AllergyIntoleranceUncheckedCreateWithoutPatientInput>
  }

  export type AllergyIntoleranceUpdateWithWhereUniqueWithoutPatientInput = {
    where: AllergyIntoleranceWhereUniqueInput
    data: XOR<AllergyIntoleranceUpdateWithoutPatientInput, AllergyIntoleranceUncheckedUpdateWithoutPatientInput>
  }

  export type AllergyIntoleranceUpdateManyWithWhereWithoutPatientInput = {
    where: AllergyIntoleranceScalarWhereInput
    data: XOR<AllergyIntoleranceUpdateManyMutationInput, AllergyIntoleranceUncheckedUpdateManyWithoutPatientInput>
  }

  export type AllergyIntoleranceScalarWhereInput = {
    AND?: AllergyIntoleranceScalarWhereInput | AllergyIntoleranceScalarWhereInput[]
    OR?: AllergyIntoleranceScalarWhereInput[]
    NOT?: AllergyIntoleranceScalarWhereInput | AllergyIntoleranceScalarWhereInput[]
    id?: StringFilter<"AllergyIntolerance"> | string
    createdAt?: DateTimeFilter<"AllergyIntolerance"> | Date | string
    patientId?: StringFilter<"AllergyIntolerance"> | string
    allergen?: StringFilter<"AllergyIntolerance"> | string
    reaction?: StringNullableFilter<"AllergyIntolerance"> | string | null
    severity?: StringNullableFilter<"AllergyIntolerance"> | string | null
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    patientId?: StringFilter<"Prescription"> | string
    medication?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    frequency?: StringFilter<"Prescription"> | string
  }

  export type ImmunizationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ImmunizationWhereUniqueInput
    update: XOR<ImmunizationUpdateWithoutPatientInput, ImmunizationUncheckedUpdateWithoutPatientInput>
    create: XOR<ImmunizationCreateWithoutPatientInput, ImmunizationUncheckedCreateWithoutPatientInput>
  }

  export type ImmunizationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ImmunizationWhereUniqueInput
    data: XOR<ImmunizationUpdateWithoutPatientInput, ImmunizationUncheckedUpdateWithoutPatientInput>
  }

  export type ImmunizationUpdateManyWithWhereWithoutPatientInput = {
    where: ImmunizationScalarWhereInput
    data: XOR<ImmunizationUpdateManyMutationInput, ImmunizationUncheckedUpdateManyWithoutPatientInput>
  }

  export type ImmunizationScalarWhereInput = {
    AND?: ImmunizationScalarWhereInput | ImmunizationScalarWhereInput[]
    OR?: ImmunizationScalarWhereInput[]
    NOT?: ImmunizationScalarWhereInput | ImmunizationScalarWhereInput[]
    id?: StringFilter<"Immunization"> | string
    createdAt?: DateTimeFilter<"Immunization"> | Date | string
    patientId?: StringFilter<"Immunization"> | string
    vaccine?: StringFilter<"Immunization"> | string
    date?: DateTimeFilter<"Immunization"> | Date | string
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutPatientInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutPatientInput>
  }

  export type ClinicalNoteScalarWhereInput = {
    AND?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    OR?: ClinicalNoteScalarWhereInput[]
    NOT?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    patientId?: StringFilter<"ClinicalNote"> | string
    content?: StringFilter<"ClinicalNote"> | string
    authorId?: StringFilter<"ClinicalNote"> | string
    signed?: BoolFilter<"ClinicalNote"> | boolean
    signedAt?: DateTimeNullableFilter<"ClinicalNote"> | Date | string | null
  }

  export type ObservationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ObservationWhereUniqueInput
    update: XOR<ObservationUpdateWithoutPatientInput, ObservationUncheckedUpdateWithoutPatientInput>
    create: XOR<ObservationCreateWithoutPatientInput, ObservationUncheckedCreateWithoutPatientInput>
  }

  export type ObservationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ObservationWhereUniqueInput
    data: XOR<ObservationUpdateWithoutPatientInput, ObservationUncheckedUpdateWithoutPatientInput>
  }

  export type ObservationUpdateManyWithWhereWithoutPatientInput = {
    where: ObservationScalarWhereInput
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyWithoutPatientInput>
  }

  export type ObservationScalarWhereInput = {
    AND?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    OR?: ObservationScalarWhereInput[]
    NOT?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    id?: StringFilter<"Observation"> | string
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    patientId?: StringFilter<"Observation"> | string
    code?: StringFilter<"Observation"> | string
    value?: StringFilter<"Observation"> | string
    unit?: StringNullableFilter<"Observation"> | string | null
  }

  export type DiagnosticReportUpsertWithWhereUniqueWithoutPatientInput = {
    where: DiagnosticReportWhereUniqueInput
    update: XOR<DiagnosticReportUpdateWithoutPatientInput, DiagnosticReportUncheckedUpdateWithoutPatientInput>
    create: XOR<DiagnosticReportCreateWithoutPatientInput, DiagnosticReportUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosticReportUpdateWithWhereUniqueWithoutPatientInput = {
    where: DiagnosticReportWhereUniqueInput
    data: XOR<DiagnosticReportUpdateWithoutPatientInput, DiagnosticReportUncheckedUpdateWithoutPatientInput>
  }

  export type DiagnosticReportUpdateManyWithWhereWithoutPatientInput = {
    where: DiagnosticReportScalarWhereInput
    data: XOR<DiagnosticReportUpdateManyMutationInput, DiagnosticReportUncheckedUpdateManyWithoutPatientInput>
  }

  export type DiagnosticReportScalarWhereInput = {
    AND?: DiagnosticReportScalarWhereInput | DiagnosticReportScalarWhereInput[]
    OR?: DiagnosticReportScalarWhereInput[]
    NOT?: DiagnosticReportScalarWhereInput | DiagnosticReportScalarWhereInput[]
    id?: StringFilter<"DiagnosticReport"> | string
    createdAt?: DateTimeFilter<"DiagnosticReport"> | Date | string
    patientId?: StringFilter<"DiagnosticReport"> | string
    code?: StringFilter<"DiagnosticReport"> | string
    result?: StringFilter<"DiagnosticReport"> | string
  }

  export type DocumentReferenceUpsertWithWhereUniqueWithoutPatientInput = {
    where: DocumentReferenceWhereUniqueInput
    update: XOR<DocumentReferenceUpdateWithoutPatientInput, DocumentReferenceUncheckedUpdateWithoutPatientInput>
    create: XOR<DocumentReferenceCreateWithoutPatientInput, DocumentReferenceUncheckedCreateWithoutPatientInput>
  }

  export type DocumentReferenceUpdateWithWhereUniqueWithoutPatientInput = {
    where: DocumentReferenceWhereUniqueInput
    data: XOR<DocumentReferenceUpdateWithoutPatientInput, DocumentReferenceUncheckedUpdateWithoutPatientInput>
  }

  export type DocumentReferenceUpdateManyWithWhereWithoutPatientInput = {
    where: DocumentReferenceScalarWhereInput
    data: XOR<DocumentReferenceUpdateManyMutationInput, DocumentReferenceUncheckedUpdateManyWithoutPatientInput>
  }

  export type DocumentReferenceScalarWhereInput = {
    AND?: DocumentReferenceScalarWhereInput | DocumentReferenceScalarWhereInput[]
    OR?: DocumentReferenceScalarWhereInput[]
    NOT?: DocumentReferenceScalarWhereInput | DocumentReferenceScalarWhereInput[]
    id?: StringFilter<"DocumentReference"> | string
    createdAt?: DateTimeFilter<"DocumentReference"> | Date | string
    patientId?: StringFilter<"DocumentReference"> | string
    title?: StringFilter<"DocumentReference"> | string
    url?: StringFilter<"DocumentReference"> | string
    type?: StringFilter<"DocumentReference"> | string
  }

  export type ItemBatchCreateWithoutItemInput = {
    id?: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutBatchInput
  }

  export type ItemBatchUncheckedCreateWithoutItemInput = {
    id?: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutBatchInput
  }

  export type ItemBatchCreateOrConnectWithoutItemInput = {
    where: ItemBatchWhereUniqueInput
    create: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput>
  }

  export type ItemBatchCreateManyItemInputEnvelope = {
    data: ItemBatchCreateManyItemInput | ItemBatchCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutItemInput = {
    id?: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
    batch?: ItemBatchCreateNestedOneWithoutMovementsInput
    performedBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutItemInput = {
    id?: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementCreateManyItemInputEnvelope = {
    data: InventoryMovementCreateManyItemInput | InventoryMovementCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemBatchUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemBatchWhereUniqueInput
    update: XOR<ItemBatchUpdateWithoutItemInput, ItemBatchUncheckedUpdateWithoutItemInput>
    create: XOR<ItemBatchCreateWithoutItemInput, ItemBatchUncheckedCreateWithoutItemInput>
  }

  export type ItemBatchUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemBatchWhereUniqueInput
    data: XOR<ItemBatchUpdateWithoutItemInput, ItemBatchUncheckedUpdateWithoutItemInput>
  }

  export type ItemBatchUpdateManyWithWhereWithoutItemInput = {
    where: ItemBatchScalarWhereInput
    data: XOR<ItemBatchUpdateManyMutationInput, ItemBatchUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemBatchScalarWhereInput = {
    AND?: ItemBatchScalarWhereInput | ItemBatchScalarWhereInput[]
    OR?: ItemBatchScalarWhereInput[]
    NOT?: ItemBatchScalarWhereInput | ItemBatchScalarWhereInput[]
    id?: StringFilter<"ItemBatch"> | string
    itemId?: StringFilter<"ItemBatch"> | string
    batchCode?: StringFilter<"ItemBatch"> | string
    expirationDate?: DateTimeNullableFilter<"ItemBatch"> | Date | string | null
    unitCost?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFilter<"ItemBatch"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ItemBatch"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutItemInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemCreateWithoutBatchesInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutBatchesInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutBatchesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBatchesInput, ItemUncheckedCreateWithoutBatchesInput>
  }

  export type InventoryMovementCreateWithoutBatchInput = {
    id?: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutMovementsInput
    performedBy: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutBatchInput = {
    id?: string
    itemId: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutBatchInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput>
  }

  export type InventoryMovementCreateManyBatchInputEnvelope = {
    data: InventoryMovementCreateManyBatchInput | InventoryMovementCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutBatchesInput = {
    update: XOR<ItemUpdateWithoutBatchesInput, ItemUncheckedUpdateWithoutBatchesInput>
    create: XOR<ItemCreateWithoutBatchesInput, ItemUncheckedCreateWithoutBatchesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBatchesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBatchesInput, ItemUncheckedUpdateWithoutBatchesInput>
  }

  export type ItemUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutBatchInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutBatchInput, InventoryMovementUncheckedUpdateWithoutBatchInput>
    create: XOR<InventoryMovementCreateWithoutBatchInput, InventoryMovementUncheckedCreateWithoutBatchInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutBatchInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutBatchInput, InventoryMovementUncheckedUpdateWithoutBatchInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutBatchInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutBatchInput>
  }

  export type ItemCreateWithoutMovementsInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    batches?: ItemBatchCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutMovementsInput = {
    id?: string
    name: string
    category?: string | null
    unit: string
    sku?: string | null
    minStock?: number
    isControlled?: boolean
    createdAt?: Date | string
    batches?: ItemBatchUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutMovementsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutMovementsInput, ItemUncheckedCreateWithoutMovementsInput>
  }

  export type ItemBatchCreateWithoutMovementsInput = {
    id?: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutBatchesInput
  }

  export type ItemBatchUncheckedCreateWithoutMovementsInput = {
    id?: string
    itemId: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ItemBatchCreateOrConnectWithoutMovementsInput = {
    where: ItemBatchWhereUniqueInput
    create: XOR<ItemBatchCreateWithoutMovementsInput, ItemBatchUncheckedCreateWithoutMovementsInput>
  }

  export type UserCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutProfessionalInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutProfessionalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type ItemUpsertWithoutMovementsInput = {
    update: XOR<ItemUpdateWithoutMovementsInput, ItemUncheckedUpdateWithoutMovementsInput>
    create: XOR<ItemCreateWithoutMovementsInput, ItemUncheckedCreateWithoutMovementsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutMovementsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutMovementsInput, ItemUncheckedUpdateWithoutMovementsInput>
  }

  export type ItemUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ItemBatchUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: FloatFieldUpdateOperationsInput | number
    isControlled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: ItemBatchUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemBatchUpsertWithoutMovementsInput = {
    update: XOR<ItemBatchUpdateWithoutMovementsInput, ItemBatchUncheckedUpdateWithoutMovementsInput>
    create: XOR<ItemBatchCreateWithoutMovementsInput, ItemBatchUncheckedCreateWithoutMovementsInput>
    where?: ItemBatchWhereInput
  }

  export type ItemBatchUpdateToOneWithWhereWithoutMovementsInput = {
    where?: ItemBatchWhereInput
    data: XOR<ItemBatchUpdateWithoutMovementsInput, ItemBatchUncheckedUpdateWithoutMovementsInput>
  }

  export type ItemBatchUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type ItemBatchUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutInventoryMovementsInput = {
    update: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutProfessionalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutProfessionalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProcedureCreateWithoutProcedureTypeInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutProceduresInput
    professional: UserCreateNestedOneWithoutProceduresInput
    costSheet?: CostSheetCreateNestedOneWithoutProcedureInput
    payments?: PaymentCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutProcedureTypeInput = {
    id?: string
    patientId: string
    professionalUserId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    costSheet?: CostSheetUncheckedCreateNestedOneWithoutProcedureInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutProcedureTypeInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput>
  }

  export type ProcedureCreateManyProcedureTypeInputEnvelope = {
    data: ProcedureCreateManyProcedureTypeInput | ProcedureCreateManyProcedureTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureUpsertWithWhereUniqueWithoutProcedureTypeInput = {
    where: ProcedureWhereUniqueInput
    update: XOR<ProcedureUpdateWithoutProcedureTypeInput, ProcedureUncheckedUpdateWithoutProcedureTypeInput>
    create: XOR<ProcedureCreateWithoutProcedureTypeInput, ProcedureUncheckedCreateWithoutProcedureTypeInput>
  }

  export type ProcedureUpdateWithWhereUniqueWithoutProcedureTypeInput = {
    where: ProcedureWhereUniqueInput
    data: XOR<ProcedureUpdateWithoutProcedureTypeInput, ProcedureUncheckedUpdateWithoutProcedureTypeInput>
  }

  export type ProcedureUpdateManyWithWhereWithoutProcedureTypeInput = {
    where: ProcedureScalarWhereInput
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyWithoutProcedureTypeInput>
  }

  export type PatientCreateWithoutProceduresInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutProceduresInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutProceduresInput, PatientUncheckedCreateWithoutProceduresInput>
  }

  export type UserCreateWithoutProceduresInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutPerformedByInput
  }

  export type UserUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutPerformedByInput
  }

  export type UserCreateOrConnectWithoutProceduresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProceduresInput, UserUncheckedCreateWithoutProceduresInput>
  }

  export type ProcedureTypeCreateWithoutProceduresInput = {
    id?: string
    name: string
    description?: string | null
    defaultDurationMin: number
    defaultItems: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureTypeUncheckedCreateWithoutProceduresInput = {
    id?: string
    name: string
    description?: string | null
    defaultDurationMin: number
    defaultItems: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureTypeCreateOrConnectWithoutProceduresInput = {
    where: ProcedureTypeWhereUniqueInput
    create: XOR<ProcedureTypeCreateWithoutProceduresInput, ProcedureTypeUncheckedCreateWithoutProceduresInput>
  }

  export type CostSheetCreateWithoutProcedureInput = {
    id?: string
    itemsCost: Decimal | DecimalJsLike | number | string
    laborCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginTarget: Decimal | DecimalJsLike | number | string
    suggestedPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostSheetUncheckedCreateWithoutProcedureInput = {
    id?: string
    itemsCost: Decimal | DecimalJsLike | number | string
    laborCost: Decimal | DecimalJsLike | number | string
    overheadCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    marginTarget: Decimal | DecimalJsLike | number | string
    suggestedPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostSheetCreateOrConnectWithoutProcedureInput = {
    where: CostSheetWhereUniqueInput
    create: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
  }

  export type PaymentCreateWithoutProcedureInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
  }

  export type PaymentUncheckedCreateWithoutProcedureInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutProcedureInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput>
  }

  export type PaymentCreateManyProcedureInputEnvelope = {
    data: PaymentCreateManyProcedureInput | PaymentCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutProceduresInput = {
    update: XOR<PatientUpdateWithoutProceduresInput, PatientUncheckedUpdateWithoutProceduresInput>
    create: XOR<PatientCreateWithoutProceduresInput, PatientUncheckedCreateWithoutProceduresInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutProceduresInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutProceduresInput, PatientUncheckedUpdateWithoutProceduresInput>
  }

  export type PatientUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutProceduresInput = {
    update: XOR<UserUpdateWithoutProceduresInput, UserUncheckedUpdateWithoutProceduresInput>
    create: XOR<UserCreateWithoutProceduresInput, UserUncheckedCreateWithoutProceduresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProceduresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProceduresInput, UserUncheckedUpdateWithoutProceduresInput>
  }

  export type UserUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutPerformedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutPerformedByNestedInput
  }

  export type ProcedureTypeUpsertWithoutProceduresInput = {
    update: XOR<ProcedureTypeUpdateWithoutProceduresInput, ProcedureTypeUncheckedUpdateWithoutProceduresInput>
    create: XOR<ProcedureTypeCreateWithoutProceduresInput, ProcedureTypeUncheckedCreateWithoutProceduresInput>
    where?: ProcedureTypeWhereInput
  }

  export type ProcedureTypeUpdateToOneWithWhereWithoutProceduresInput = {
    where?: ProcedureTypeWhereInput
    data: XOR<ProcedureTypeUpdateWithoutProceduresInput, ProcedureTypeUncheckedUpdateWithoutProceduresInput>
  }

  export type ProcedureTypeUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
  }

  export type ProcedureTypeUncheckedUpdateWithoutProceduresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationMin?: IntFieldUpdateOperationsInput | number
    defaultItems?: JsonNullValueInput | InputJsonValue
  }

  export type CostSheetUpsertWithoutProcedureInput = {
    update: XOR<CostSheetUpdateWithoutProcedureInput, CostSheetUncheckedUpdateWithoutProcedureInput>
    create: XOR<CostSheetCreateWithoutProcedureInput, CostSheetUncheckedCreateWithoutProcedureInput>
    where?: CostSheetWhereInput
  }

  export type CostSheetUpdateToOneWithWhereWithoutProcedureInput = {
    where?: CostSheetWhereInput
    data: XOR<CostSheetUpdateWithoutProcedureInput, CostSheetUncheckedUpdateWithoutProcedureInput>
  }

  export type CostSheetUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostSheetUncheckedUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overheadCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    suggestedPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutProcedureInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutProcedureInput, PaymentUncheckedUpdateWithoutProcedureInput>
    create: XOR<PaymentCreateWithoutProcedureInput, PaymentUncheckedCreateWithoutProcedureInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutProcedureInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutProcedureInput, PaymentUncheckedUpdateWithoutProcedureInput>
  }

  export type PaymentUpdateManyWithWhereWithoutProcedureInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutProcedureInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    procedureId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type ProcedureCreateWithoutCostSheetInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutProceduresInput
    professional: UserCreateNestedOneWithoutProceduresInput
    procedureType: ProcedureTypeCreateNestedOneWithoutProceduresInput
    payments?: PaymentCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutCostSheetInput = {
    id?: string
    patientId: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutCostSheetInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutCostSheetInput, ProcedureUncheckedCreateWithoutCostSheetInput>
  }

  export type ProcedureUpsertWithoutCostSheetInput = {
    update: XOR<ProcedureUpdateWithoutCostSheetInput, ProcedureUncheckedUpdateWithoutCostSheetInput>
    create: XOR<ProcedureCreateWithoutCostSheetInput, ProcedureUncheckedCreateWithoutCostSheetInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutCostSheetInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutCostSheetInput, ProcedureUncheckedUpdateWithoutCostSheetInput>
  }

  export type ProcedureUpdateWithoutCostSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutProceduresNestedInput
    professional?: UserUpdateOneRequiredWithoutProceduresNestedInput
    procedureType?: ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput
    payments?: PaymentUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutCostSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureCreateWithoutPaymentsInput = {
    id?: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    patient: PatientCreateNestedOneWithoutProceduresInput
    professional: UserCreateNestedOneWithoutProceduresInput
    procedureType: ProcedureTypeCreateNestedOneWithoutProceduresInput
    costSheet?: CostSheetCreateNestedOneWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateWithoutPaymentsInput = {
    id?: string
    patientId: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
    costSheet?: CostSheetUncheckedCreateNestedOneWithoutProcedureInput
  }

  export type ProcedureCreateOrConnectWithoutPaymentsInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutPaymentsInput, ProcedureUncheckedCreateWithoutPaymentsInput>
  }

  export type ProcedureUpsertWithoutPaymentsInput = {
    update: XOR<ProcedureUpdateWithoutPaymentsInput, ProcedureUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ProcedureCreateWithoutPaymentsInput, ProcedureUncheckedCreateWithoutPaymentsInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutPaymentsInput, ProcedureUncheckedUpdateWithoutPaymentsInput>
  }

  export type ProcedureUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutProceduresNestedInput
    professional?: UserUpdateOneRequiredWithoutProceduresNestedInput
    procedureType?: ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput
    costSheet?: CostSheetUpdateOneWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    costSheet?: CostSheetUncheckedUpdateOneWithoutProcedureNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutProfessionalInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutPerformedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    role: $Enums.Role
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutProfessionalInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutPerformedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutProfessionalNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutPerformedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutProfessionalNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutPerformedByNestedInput
  }

  export type PatientCreateWithoutClinicalNotesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutClinicalNotesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutClinicalNotesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
  }

  export type PatientUpsertWithoutClinicalNotesInput = {
    update: XOR<PatientUpdateWithoutClinicalNotesInput, PatientUncheckedUpdateWithoutClinicalNotesInput>
    create: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutClinicalNotesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutClinicalNotesInput, PatientUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type PatientUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutObservationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutObservationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutObservationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutObservationsInput, PatientUncheckedCreateWithoutObservationsInput>
  }

  export type PatientUpsertWithoutObservationsInput = {
    update: XOR<PatientUpdateWithoutObservationsInput, PatientUncheckedUpdateWithoutObservationsInput>
    create: XOR<PatientCreateWithoutObservationsInput, PatientUncheckedCreateWithoutObservationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutObservationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutObservationsInput, PatientUncheckedUpdateWithoutObservationsInput>
  }

  export type PatientUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutMedicationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
  }

  export type PatientUpsertWithoutMedicationsInput = {
    update: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
    create: XOR<PatientCreateWithoutMedicationsInput, PatientUncheckedCreateWithoutMedicationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicationsInput, PatientUncheckedUpdateWithoutMedicationsInput>
  }

  export type PatientUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutDiagnosticReportsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDiagnosticReportsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDiagnosticReportsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDiagnosticReportsInput, PatientUncheckedCreateWithoutDiagnosticReportsInput>
  }

  export type PatientUpsertWithoutDiagnosticReportsInput = {
    update: XOR<PatientUpdateWithoutDiagnosticReportsInput, PatientUncheckedUpdateWithoutDiagnosticReportsInput>
    create: XOR<PatientCreateWithoutDiagnosticReportsInput, PatientUncheckedCreateWithoutDiagnosticReportsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDiagnosticReportsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDiagnosticReportsInput, PatientUncheckedUpdateWithoutDiagnosticReportsInput>
  }

  export type PatientUpdateWithoutDiagnosticReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDiagnosticReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutAllergiesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAllergiesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAllergiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
  }

  export type PatientUpsertWithoutAllergiesInput = {
    update: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutDocumentReferencesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDocumentReferencesInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDocumentReferencesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDocumentReferencesInput, PatientUncheckedCreateWithoutDocumentReferencesInput>
  }

  export type PatientUpsertWithoutDocumentReferencesInput = {
    update: XOR<PatientUpdateWithoutDocumentReferencesInput, PatientUncheckedUpdateWithoutDocumentReferencesInput>
    create: XOR<PatientCreateWithoutDocumentReferencesInput, PatientUncheckedCreateWithoutDocumentReferencesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDocumentReferencesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDocumentReferencesInput, PatientUncheckedUpdateWithoutDocumentReferencesInput>
  }

  export type PatientUpdateWithoutDocumentReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDocumentReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutConditionsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConditionsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    immunizations?: ImmunizationUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConditionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConditionsInput, PatientUncheckedCreateWithoutConditionsInput>
  }

  export type PatientUpsertWithoutConditionsInput = {
    update: XOR<PatientUpdateWithoutConditionsInput, PatientUncheckedUpdateWithoutConditionsInput>
    create: XOR<PatientCreateWithoutConditionsInput, PatientUncheckedCreateWithoutConditionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConditionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConditionsInput, PatientUncheckedUpdateWithoutConditionsInput>
  }

  export type PatientUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    immunizations?: ImmunizationUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutImmunizationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureCreateNestedManyWithoutPatientInput
    conditions?: ConditionCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceCreateNestedManyWithoutPatientInput
    medications?: PrescriptionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    observations?: ObservationCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutImmunizationsInput = {
    id?: string
    name: string
    birthDate?: Date | string | null
    document?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    consentGivenAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    procedures?: ProcedureUncheckedCreateNestedManyWithoutPatientInput
    conditions?: ConditionUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergyIntoleranceUncheckedCreateNestedManyWithoutPatientInput
    medications?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    observations?: ObservationUncheckedCreateNestedManyWithoutPatientInput
    diagnosticReports?: DiagnosticReportUncheckedCreateNestedManyWithoutPatientInput
    documentReferences?: DocumentReferenceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutImmunizationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutImmunizationsInput, PatientUncheckedCreateWithoutImmunizationsInput>
  }

  export type PatientUpsertWithoutImmunizationsInput = {
    update: XOR<PatientUpdateWithoutImmunizationsInput, PatientUncheckedUpdateWithoutImmunizationsInput>
    create: XOR<PatientCreateWithoutImmunizationsInput, PatientUncheckedCreateWithoutImmunizationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutImmunizationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutImmunizationsInput, PatientUncheckedUpdateWithoutImmunizationsInput>
  }

  export type PatientUpdateWithoutImmunizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    observations?: ObservationUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutImmunizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    consentGivenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procedures?: ProcedureUncheckedUpdateManyWithoutPatientNestedInput
    conditions?: ConditionUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergyIntoleranceUncheckedUpdateManyWithoutPatientNestedInput
    medications?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutPatientNestedInput
    diagnosticReports?: DiagnosticReportUncheckedUpdateManyWithoutPatientNestedInput
    documentReferences?: DocumentReferenceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ProcedureCreateManyProfessionalInput = {
    id?: string
    patientId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    userName?: string | null
    userRole?: string | null
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenantId?: string | null
    resourceType?: string | null
    resourceId?: string | null
    description?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    accessPurpose?: string | null
    justification?: string | null
    previousHash?: string | null
    currentHash?: string | null
    timestamp?: Date | string
  }

  export type InventoryMovementCreateManyPerformedByInput = {
    id?: string
    itemId: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    createdAt?: Date | string
  }

  export type ProcedureUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutProceduresNestedInput
    procedureType?: ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput
    costSheet?: CostSheetUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    costSheet?: CostSheetUncheckedUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    accessPurpose?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    previousHash?: NullableStringFieldUpdateOperationsInput | string | null
    currentHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutMovementsNestedInput
    batch?: ItemBatchUpdateOneWithoutMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateManyPatientInput = {
    id?: string
    professionalUserId: string
    procedureTypeId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
  }

  export type ConditionCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    name: string
    status: string
  }

  export type AllergyIntoleranceCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    allergen: string
    reaction?: string | null
    severity?: string | null
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    medication: string
    dosage: string
    frequency: string
  }

  export type ImmunizationCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    vaccine: string
    date: Date | string
  }

  export type ClinicalNoteCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    content: string
    authorId: string
    signed?: boolean
    signedAt?: Date | string | null
  }

  export type ObservationCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    value: string
    unit?: string | null
  }

  export type DiagnosticReportCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    code: string
    result: string
  }

  export type DocumentReferenceCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    title: string
    url: string
    type: string
  }

  export type ProcedureUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    professional?: UserUpdateOneRequiredWithoutProceduresNestedInput
    procedureType?: ProcedureTypeUpdateOneRequiredWithoutProceduresNestedInput
    costSheet?: CostSheetUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    costSheet?: CostSheetUncheckedUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    procedureTypeId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AllergyIntoleranceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyIntoleranceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AllergyIntoleranceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergen?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
  }

  export type ImmunizationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ObservationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiagnosticReportUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosticReportUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosticReportUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentReferenceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentReferenceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentReferenceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ItemBatchCreateManyItemInput = {
    id?: string
    batchCode: string
    expirationDate?: Date | string | null
    unitCost: Decimal | DecimalJsLike | number | string
    quantityAvailable: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type InventoryMovementCreateManyItemInput = {
    id?: string
    batchId?: string | null
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type ItemBatchUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutBatchNestedInput
  }

  export type ItemBatchUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type ItemBatchUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchCode?: StringFieldUpdateOperationsInput | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityAvailable?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: ItemBatchUpdateOneWithoutMovementsNestedInput
    performedBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyBatchInput = {
    id?: string
    itemId: string
    type: $Enums.MovementType
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    linkedProcedureId?: string | null
    performedByUserId: string
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutMovementsNestedInput
    performedBy?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    linkedProcedureId?: NullableStringFieldUpdateOperationsInput | string | null
    performedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureCreateManyProcedureTypeInput = {
    id?: string
    patientId: string
    professionalUserId: string
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    room?: string | null
    status?: $Enums.ProcedureStatus
    notes?: string | null
  }

  export type ProcedureUpdateWithoutProcedureTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutProceduresNestedInput
    professional?: UserUpdateOneRequiredWithoutProceduresNestedInput
    costSheet?: CostSheetUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateWithoutProcedureTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    costSheet?: CostSheetUncheckedUpdateOneWithoutProcedureNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateManyWithoutProcedureTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    professionalUserId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcedureStatusFieldUpdateOperationsInput | $Enums.ProcedureStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyProcedureInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PaymentStatus
    paidAt?: Date | string | null
  }

  export type PaymentUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutProcedureInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}